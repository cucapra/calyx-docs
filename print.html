<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Calyx Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Calyx Language</li><li class="chapter-item expanded "><a href="tutorial/language-tut.html"><strong aria-hidden="true">1.</strong> Language Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang/multi-component.html"><strong aria-hidden="true">1.1.</strong> Multi-Component Designs</a></li><li class="chapter-item expanded "><a href="lang/memories-by-reference.html"><strong aria-hidden="true">1.2.</strong> Passing Memories by Reference</a></li></ol></li><li class="chapter-item expanded "><a href="lang/ref.html"><strong aria-hidden="true">2.</strong> Language Reference</a></li><li class="chapter-item expanded "><a href="lang/sync.html"><strong aria-hidden="true">3.</strong> Experimental: Synchronization</a></li><li class="chapter-item expanded "><a href="lang/attributes.html"><strong aria-hidden="true">4.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="lang/undefined.html"><strong aria-hidden="true">5.</strong> Undefined Behaviors</a></li><li class="chapter-item expanded affix "><li class="part-title">Running Calyx Programs</li><li class="chapter-item expanded "><a href="fud/index.html"><strong aria-hidden="true">6.</strong> fud: The Calyx Driver</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fud/examples.html"><strong aria-hidden="true">6.1.</strong> Examples</a></li><li class="chapter-item expanded "><a href="fud/xilinx.html"><strong aria-hidden="true">6.2.</strong> Xilinx Tools</a></li><li class="chapter-item expanded "><a href="fud/external.html"><strong aria-hidden="true">6.3.</strong> External Stages</a></li><li class="chapter-item expanded "><a href="fud/multiple-paths.html"><strong aria-hidden="true">6.4.</strong> Multiple Paths</a></li><li class="chapter-item expanded "><a href="fud/circt.html"><strong aria-hidden="true">6.5.</strong> CIRCT</a></li></ol></li><li class="chapter-item expanded "><a href="interpreter.html"><strong aria-hidden="true">7.</strong> The Calyx Interpreter</a></li><li class="chapter-item expanded affix "><li class="part-title">The Calyx Compiler</li><li class="chapter-item expanded "><a href="compiler.html"><strong aria-hidden="true">8.</strong> The Calyx Compiler</a></li><li class="chapter-item expanded "><a href="libraries/core.html"><strong aria-hidden="true">9.</strong> Primitive Library</a></li><li class="chapter-item expanded "><a href="compiler-as-library.html"><strong aria-hidden="true">10.</strong> The calyx Library</a></li><li class="chapter-item expanded "><a href="optimizations/dataflow.html"><strong aria-hidden="true">11.</strong> Dataflow Analysis</a></li><li class="chapter-item expanded "><a href="debug/index.html"><strong aria-hidden="true">12.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="debug/cider.html"><strong aria-hidden="true">12.1.</strong> Logical Bugs</a></li><li class="chapter-item expanded "><a href="debug/debug.html"><strong aria-hidden="true">12.2.</strong> Compilation Bugs</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Generating Calyx</li><li class="chapter-item expanded "><a href="calyx-py.html"><strong aria-hidden="true">13.</strong> Emitting Calyx from Python</a></li><li class="chapter-item expanded "><a href="tutorial/frontend-tut.html"><strong aria-hidden="true">14.</strong> Frontend Tutorial</a></li><li class="chapter-item expanded "><a href="frontends/index.html"><strong aria-hidden="true">15.</strong> Frontend Compilers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="frontends/dahlia.html"><strong aria-hidden="true">15.1.</strong> Dahlia</a></li><li class="chapter-item expanded "><a href="frontends/systolic-array.html"><strong aria-hidden="true">15.2.</strong> Systolic Array Generator</a></li><li class="chapter-item expanded "><a href="frontends/tvm-relay.html"><strong aria-hidden="true">15.3.</strong> TVM Relay</a></li><li class="chapter-item expanded "><a href="frontends/ntt.html"><strong aria-hidden="true">15.4.</strong> NTT Pipeline Generator</a></li><li class="chapter-item expanded "><a href="frontends/mrxl.html"><strong aria-hidden="true">15.5.</strong> MrXL</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Tools</li><li class="chapter-item expanded "><a href="tools/runt.html"><strong aria-hidden="true">16.</strong> Runt</a></li><li class="chapter-item expanded "><a href="tools/exp-generator.html"><strong aria-hidden="true">17.</strong> exp Generator</a></li><li class="chapter-item expanded "><a href="tools/editor-highlighting.html"><strong aria-hidden="true">18.</strong> Editor Highlighting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Calyx Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Calyx is an intermediate language and infrastructure for building compilers
that generate custom hardware accelerators.
These instructions will help you set up the Calyx compiler and associated
tools.
By the end, you should be able to compile and simulate hardware designs
generated by Calyx.</p>
<h2 id="compiler-installation"><a class="header" href="#compiler-installation">Compiler Installation</a></h2>
<p>Install <a href="https://doc.rust-lang.org/cargo/getting-started/installation.html">Rust</a> (it should automatically install <code>cargo</code>).</p>
<p>Clone the repository:</p>
<pre><code>git clone https://github.com/cucapra/calyx.git
</code></pre>
<p>Then build the compiler:</p>
<pre><code>cargo build
</code></pre>
<p>You can invoke the compiler in one of two ways:</p>
<pre><code>cargo run -- --help # Rebuilds the compiler if the sources changed
./target/debug/futil --help # Default debug build of the compiler
</code></pre>
<h2 id="running-core-tests"><a class="header" href="#running-core-tests">Running Core Tests</a></h2>
<p>The core test suites tests the Calyx compiler passes.
Install the following tools for running the core tests:</p>
<ol>
<li><a href="https://github.com/rachitnigam/runt">runt</a> hosts our testing infrastructure. Install with:
<code>cargo install runt</code></li>
<li><a href="https://stedolan.github.io/jq/">jq</a> is a command-line JSON processor:
<ul>
<li>Ubuntu: <code>sudo apt install jq</code></li>
<li>Mac: <code>brew install jq</code></li>
<li>Other platforms: <a href="https://stedolan.github.io/jq/">JQ installation</a></li>
</ul>
</li>
</ol>
<p>Build the compiler:</p>
<pre><code>cargo build
</code></pre>
<p>Then run the core tests with:</p>
<pre><code>runt -i core
</code></pre>
<p>If everything has been installed correctly, this should not produce any failing
tests.</p>
<h2 id="installing-the-command-line-driver"><a class="header" href="#installing-the-command-line-driver">Installing the Command-Line Driver</a></h2>
<p><a href="./fud">The Calyx driver</a> wraps the various compiler frontends and
backends to simplify running Calyx programs.</p>
<p>Install <a href="https://flit.readthedocs.io/en/latest/">Flit</a>:</p>
<pre><code>pip3 install flit
</code></pre>
<p>Install <code>fud</code> (from the root of the repository):</p>
<pre><code>flit -f fud/pyproject.toml install -s --deps production
</code></pre>
<p>Configure <code>fud</code>:</p>
<pre><code>fud config global.futil_directory &lt;full path to Calyx repository&gt;
</code></pre>
<p>Check the <code>fud</code> configuration:</p>
<pre><code>fud check
</code></pre>
<p><code>fud</code> will report certain tools are not available. This is expected.</p>
<h2 id="simulation"><a class="header" href="#simulation">Simulation</a></h2>
<p>There are three ways to run Calyx programs:
<a href="https://www.veripool.org/wiki/verilator">Verilator</a>, <a href="http://iverilog.icarus.com">Icarus Verilog</a>, and Calyx's native <a href="./interpreter.html">interpreter</a>.
You'll want to set up at least one of these options so you can try out your code.</p>
<p>Icarus is an easy way to get started on most platforms.
On a Mac, you can install Icarus Verilog with <a href="https://brew.sh">Homebrew</a> by typing <code>brew install icarus-verilog</code>.
On Ubuntu, <a href="https://iverilog.fandom.com/wiki/Installation_Guide#Installation_From_Source">install from source</a>.
Then install the relevant <a href="./fud/index.html#icarus-verilog">fud support</a> by running:</p>
<pre><code>fud register icarus-verilog -p fud/icarus/icarus.py
</code></pre>
<p>Type <code>fud check</code> to make sure the new stage is working.
(Some missing tools are expected; just pay attention to the report for <code>stages.icarus-verilog.exec</code>.)</p>
<p>You can instead consider <a href="./fud/index.html#verilator">setting up Verilator</a> for faster long-running simulations or using the <a href="./interpreter.html">interpreter</a> to avoid RTL simulation altogether.</p>
<h2 id="running-a-hardware-design"><a class="header" href="#running-a-hardware-design">Running a Hardware Design</a></h2>
<p>We're all set to run a Calyx hardware design now. Run the following command:</p>
<pre><code>fud e examples/tutorial/language-tutorial-iterate.futil \
  -s verilog.data examples/tutorial/data.json \
  --to dat --through icarus-verilog -v
</code></pre>
<p>(Change the last bit to <code>--through verilog</code> to use Verilator instead.)</p>
<p>This command will compile <code>examples/tutorial/language-tutorial-iterate.futil</code> to Verilog
using the Calyx compiler, simulate the design using the data in <code>examples/tutorial/data.json</code>, and generate a JSON representation of the
final memory state.</p>
<p>Congratulations! You've simulated your first hardware design with Calyx.</p>
<h2 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to go next?</a></h2>
<ul>
<li><a href="./tools/editor-highlighting.html">How can I setup syntax highlighting in my editor?</a></li>
<li><a href="./tutorial/language-tut.html">How does the language work?</a></li>
<li><a href="./fud/index.html#dahlia-fronted">How do I install Calyx frontends?</a></li>
<li><a href="./fud/examples.html">Examples with <code>fud</code></a></li>
<li><a href="./tutorial/frontend-tut.html">How do I write a frontend for Calyx?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calyx-language-tutorial"><a class="header" href="#calyx-language-tutorial">Calyx Language Tutorial</a></h1>
<p>This tutorial will familiarize you with the Calyx language by writing a minimal program <em>by hand</em>.
Usually, Calyx code will be generated by a frontend.
However, by writing the program by hand, you can get familiar with all the
basic constructs you need to generate Calyx yourself!</p>
<p>Complete code for each example can be found in the <a href="https://github.com/cucapra/calyx/tree/master/examples/tutorial">tutorial</a> directory in
the Calyx repository.</p>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<p>The basic building block of Calyx programs is a <em>component</em> which corresponds
to hardware modules (or function definitions for the software-minded).</p>
<p>Here is an empty component definition for <code>main</code> along with an <code>import</code>
statement to import the standard library:</p>
<pre><code>import &quot;primitives/core.futil&quot;;

component main(go: 1) -&gt; (done: 1) {
  cells {
  }

  wires {
  }

  control {
  }
}
</code></pre>
<p>Put this in a file—you can call it <code>language-tutorial-mem.futil</code>, for example.
(The <code>futil</code> file extension comes from an old name for Calyx.)</p>
<p>You can think of a component as a unit of Calyx code roughly analogous to a function: it encapsulates a logical unit of hardware structures along with their control.
Every component definition has three sections:</p>
<ul>
<li><code>cells</code>: The hardware subcomponents that make up this component.</li>
<li><code>wires</code>: A set of guarded connections between components, possibly organized into <em>groups</em>.</li>
<li><code>control</code>: The imperative program that defines the component's execution schedule: i.e., when each group executes.</li>
</ul>
<p>We'll fill these sections up minimally in the next sections.</p>
<h2 id="a-memory-cell"><a class="header" href="#a-memory-cell">A Memory Cell</a></h2>
<p>Let's turn our skeleton into a tiny, nearly no-op Calyx program.
We'll start by adding a memory component to the cells:</p>
<pre><code>  cells {
    @external(1) mem = std_mem_d1(32, 1, 1);
  }
</code></pre>
<p>This new line declares a new cell called <code>mem</code> and the primitive component <code>std_mem_d1</code> represents a 1D memory.
You can see the definition of <code>std_mem_d1</code>, and all the other standard components, in the <code>primitives/core.futil</code> library we imported.</p>
<p>This one has three parameters:
the data width (here, 32 bits),
the number of elements (just one),
and the width of the address port (one bit).</p>
<p>The <code>@external(1)</code> syntax is an <a href="tutorial/../lang/attributes.html#external1">extra bit of magic</a> that allows us
to read and write to the memory.</p>
<p>Next, we'll add some assignments to the <code>wires</code> section to update the value in
the memory.
Insert these lines to put a constant value into the memory:</p>
<pre><code>  wires {
      mem.addr0 = 1'b0;
      mem.write_data = 32'd42;
      mem.write_en = 1'b1;
      done = mem.done;
  }
</code></pre>
<p>These assignments refer to four <em>ports</em> on the memory component:
<code>addr0</code> (the address port),
<code>write_data</code> (the value we're putting into the memory),
<code>write_en</code> (the <em>write enable</em> signal, telling the memory that it's time to do a write), and
<code>done</code> (signals that the write was committed).
Constants like <code>32'd42</code> are Verilog-like literals that include the bit width (32), the base (<code>d</code> for decimal), and the value (42).</p>
<p>Assignments at the top level in the <code>wires</code> section, like these, are &quot;continuous&quot;.
They always happen, without any need for <code>control</code> statements to orchestrate them.
We'll see later how to organize assignments into groups.</p>
<blockquote>
<p>The complete program for this section is available under <a href="https://github.com/cucapra/calyx/blob/master/examples/tutorial/language-tutorial-mem.futil">examples/tutorial/language-tutorial-mem.futil</a>.</p>
</blockquote>
<h2 id="compile--run"><a class="header" href="#compile--run">Compile &amp; Run</a></h2>
<p>We can almost run this program!
But first, we need to provide it with data.
The Calyx infrastructure can provide data to programs from <a href="https://www.json.org/">JSON</a> files.
So make a file called something like <code>data.json</code> containing something along these lines:</p>
<pre><code>{
  &quot;mem&quot;: {
    &quot;data&quot;: [10],
    &quot;format&quot;: {
      &quot;numeric_type&quot;: &quot;bitnum&quot;,
      &quot;is_signed&quot;: false,
      &quot;width&quot;: 32
    }
  }
}
</code></pre>
<p>The <code>mem</code> key means we're providing the initial value for our memory called <code>mem</code>.
We have one (unsigned integer) data element, and we indicate the bit width (32 bits).</p>
<p>If you want to see how this Calyx program compiles to Verilog, here's the <a href="tutorial/./fud/index.html">fud</a> incantation you need:</p>
<pre><code>fud exec language-tutorial-mem.futil --to verilog
</code></pre>
<p>Not terribly interesting!
However, one nice thing you can do with programs is execute them.</p>
<p>To run our program using <a href="http://iverilog.icarus.com">Icarus Verilog</a>, do this:</p>
<pre><code>fud exec language-tutorial-mem.futil --to dat --through icarus-verilog \
    -s verilog.data data.json
</code></pre>
<p>Using <code>--to dat</code> asks fud to run the program, and the extra <code>-s verilog.data &lt;filename&gt;</code> argument tells it where to find the input data.
The <code>--through icarus-verilog</code> option tells fud which Verilog simulator to use (see <a href="tutorial/./fud/index.html">the chapter about fud</a> for alternatives such as <a href="https://www.veripool.org/wiki/verilator">Verilator</a>).
Executing this program should print:</p>
<pre><code>{
  &quot;cycles&quot;: 1,
  &quot;memories&quot;: {
    &quot;mem&quot;: [
      42
    ]
  }
}
</code></pre>
<p>Meaning that, after the program finished, the final value in our memory was 42.</p>
<blockquote>
<p><strong>Note</strong>: Icarus Verilog may report a different cycle count compared to the one above. As long as the final value in memory is correct, this does not matter.</p>
</blockquote>
<h2 id="add-control"><a class="header" href="#add-control">Add Control</a></h2>
<p>Let's change our program to use an execution schedule.
First, we're going to wrap all the assignments in the <code>wires</code> section into a
name <em>group</em>:</p>
<pre><code>  wires {
    group the_answer {
      mem.addr0 = 1'b0;
      mem.write_data = 32'd42;
      mem.write_en = 1'b1;
      the_answer[done] = mem.done;
    }
  }
</code></pre>
<p>We also need one extra line in the group: that assignment to <code>the_answer[done]</code>.
Here, we say that <code>the_answer</code>'s work is one once the update to <code>mem</code> has finished.
Calyx groups have <em>compilation holes</em> called <code>go</code> and <code>done</code> that the control program will use to orchestrate their execution.</p>
<p>The last thing we need is a control program.
Add one line to activate <code>the_answer</code> and then finish:</p>
<pre><code>  control {
    the_answer;
  }
</code></pre>
<p>If you execute this program, it should do the same thing as the original group-free version: <code>mem</code> ends up with 42 in it.
But now we're controlling things with an execution schedule.</p>
<p>If you're curious to see how the Calyx compiler lowers this program to a Verilog-like structural form of Calyx, you can do this:</p>
<pre><code>fud exec language-tutorial-mem.futil --to futil-lowered
</code></pre>
<p>Notably, you'll see <code>control {}</code> in the output, meaning that the compiler has eliminated all the control statements and replaced them with continuous assignments in <code>wires</code>.</p>
<blockquote>
<p>The complete program for this section is available under <a href="https://github.com/cucapra/calyx/blob/master/examples/tutorial/language-tutorial-control.futil">examples/tutorial/language-tutorial-control.futil</a>.</p>
</blockquote>
<h2 id="add-an-adder"><a class="header" href="#add-an-adder">Add an Adder</a></h2>
<p>The next step is to actually do some computation.
In this version of the program, we'll read a value from the memory, increment it, and store the updated value back to the memory.</p>
<p>First, we will add two components to the <code>cells</code> section:</p>
<pre><code>  cells {
    @external(1) mem = std_mem_d1(32, 1, 1);
    val = std_reg(32);
    add = std_add(32);
  }
</code></pre>
<p>We make a register <code>val</code> and an integer adder <code>add</code>, both configured to work on 32-bit values.</p>
<p>Next, we'll create three groups in the <code>wires</code> section for the three steps we want to run: read, increment, and write back to the memory.
Let's start with the last step, which looks pretty similar to our <code>the_answer</code> group from above, except that the value comes from the <code>val</code> register instead of a constant:</p>
<pre><code>    group write {
      mem.addr0 = 1'b0;
      mem.write_en = 1'b1;
      mem.write_data = val.out;
      write[done] = mem.done;
    }
</code></pre>
<p>Next, let's create a group <code>read</code> that moves the value from the memory to our register <code>val</code>:</p>
<pre><code>    group read {
      mem.addr0 = 1'b0;
      val.in = mem.read_data;
      val.write_en = 1'b1;
      read[done] = val.done;
    }
</code></pre>
<p>Here, we use the memory's <code>read_data</code> port to get the initial value out.</p>
<p>Finally, we need a third group to add and update the value in the register:</p>
<pre><code>    group upd {
      add.left = val.out;
      add.right = 32'd4;
      val.in = add.out;
      val.write_en = 1'b1;
      upd[done] = val.done;
    }
</code></pre>
<p>The <code>std_add</code> component from the standard library has two input ports, <code>left</code> and <code>right</code>, and a single output port, <code>out</code>, which we hook up to the register's <code>in</code> port.
This group adds a constant 4 to the register's value, updating it in place.
We can enable the <code>val</code> register with a constant 1 because the <code>std_add</code> component is <em>combinational</em>, meaning its results are ready &quot;instantly&quot; without the need to wait for a done signal.</p>
<p>We need to extend our control program to orchestrate the execution of the three groups.
We will need a <code>seq</code> statement to say we want to the three steps sequentially:</p>
<pre><code>  control {
    seq {
      read;
      upd;
      write;
    }
  }
</code></pre>
<p>Try running this program again.
The memory's initial value was 10, and its final value after execution should be 14.</p>
<blockquote>
<p>The complete program for this section is available under <a href="https://github.com/cucapra/calyx/blob/master/examples/tutorial/language-tutorial-compute.futil">examples/tutorial/language-tutorial-compute.futil</a>.</p>
</blockquote>
<h2 id="iterate"><a class="header" href="#iterate">Iterate</a></h2>
<p>Next, we'd like to run our little computation in a loop.
The idea is to use Calyx's <code>while</code> control construct, which works like this:</p>
<pre><code>while &lt;value&gt; with &lt;group&gt; {
  &lt;body&gt;
}
</code></pre>
<p>A <code>while</code> loop runs the control statements in the body until <code>&lt;value&gt;</code>, which is some port on some component, becomes zero.
The <code>with &lt;group&gt;</code> bit means that we activate a given group in order to compute the condition value that determines whether the loop continues executing.</p>
<p>Let's run our memory-updating <code>seq</code> block in a while loop.
Change the control program to look like this:</p>
<pre><code>  control {
    seq {
      init;
      while lt.out with cond {
        par {
          seq {
            read;
            upd;
            write;
          }
          incr;
        }
      }
    }
  }
</code></pre>
<p>This version uses <code>while</code>, the parallel composition construct <code>par</code>, and a few new groups we will need to define.
The idea is that we'll use a counter register to make this loop run a fixed number of times, like a <code>for</code> loop.
First, we have an outer <code>seq</code> that invokes an <code>init</code> group that we will write to set the counter to zero.
The <code>while</code> loop then uses a new group <code>cond</code>, and it will run while a signal <code>lt.out</code> remains nonzero: this signal will compute <code>counter &lt; 8</code>.
The body of the loop runs our old <code>seq</code> block in parallel with a new <code>incr</code> group to increment the counter.</p>
<p>Let's add some cells to our component:</p>
<pre><code>    counter = std_reg(32);
    add2 = std_add(32);
    lt = std_lt(32);
</code></pre>
<p>We'll need a new register, an adder to do the incrementing, and a less-than comparator.</p>
<p>We can use these raw materials to build the new groups we need: <code>init</code>, <code>incr</code>, and <code>cond</code>.
First, the <code>init</code> group is pretty simple:</p>
<pre><code>    group init {
      counter.in = 32'd0;
      counter.write_en = 1'b1;
      init[done] = counter.done;
    }
</code></pre>
<p>This group just writes a zero into the counter and signals that it's done.
Next, the <code>incr</code> group adds one to the value in <code>counter</code> using <code>add2</code>:</p>
<pre><code>    group incr {
      add2.left = counter.out;
      add2.right = 32'd1;
      counter.in = add2.out;
      counter.write_en = 1'b1;
      incr[done] = counter.done;
    }
</code></pre>
<p>And finally, <code>cond</code> uses our comparator <code>lt</code> to compute the signal we need for
our <code>while</code> loop. We use a <code>comb group</code> to denote that the assignments inside
the condition can be run combinationally:</p>
<pre><code>    comb group cond {
      lt.left = counter.out;
      lt.right = 32'd8;
    }
</code></pre>
<p>By comparing with 8, we should now be running our loop body 8 times.</p>
<p>Try running this program again.
The output should be the result of adding 4 to the initial value 8 times, so 10 + 8 × 4.</p>
<blockquote>
<p>The complete program for this section is available under <a href="https://github.com/cucapra/calyx/blob/master/examples/tutorial/language-tutorial-iterate.futil">examples/tutorial/language-tutorial-iterate.futil</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-component-designs"><a class="header" href="#multi-component-designs">Multi-Component Designs</a></h1>
<p>Calyx designs can define and instantiate other Calyx components that themselves
encode complex <code>control</code> programs.</p>
<p>As an example, we'll build a Calyx design that uses a simple Calyx component
to save a value in a register and use it in different component.</p>
<p>We define a new component called <code>identity</code> that has an input port <code>in</code>
and an output port <code>out</code>.</p>
<pre><code>component identity(in: 32) -&gt; (out: 32) {
  cells {
    r = std_reg(32);
  }
  wires {
    group save {
      r.in = in;
      r.write_en = 1'd1;
      save[done] = r.done;
    }

    // This component always outputs the current value in r
    out = r.out;
  }
  control {
    save;
  }
}
</code></pre>
<p>The following line defines a <em>continuous assignment</em>, i.e., an assignment
that is always kept active, regardless of the component's <code>control</code> program
being active.</p>
<pre><code>    // This component always outputs the current value in r
    out = r.out;
</code></pre>
<p>By defining this continuous assignment, we can <em>execute</em> our component and
later observe any relevant values.</p>
<p>Next, we can instantiate this component in any other Calyx component.
The following Calyx program instantiates the <code>id</code> component and uses it to
save a value and observe it.</p>
<pre><code>component main() -&gt; () {
  cells {
    // Instantiate the identity element
    id = identity();
    current_value = std_reg(32);
  }
  wires {
    group run_id {
      // We want to &quot;save&quot; the value 10 inside the identity group.
      id.in = 32'd10;
      // All components have a magic &quot;go&quot; and &quot;done&quot; port added to them.
      // Execute the component.
      id.go = 1'd1;
      run_id[done] = id.done;
    }
    group use_id {
      // We want to &quot;observe&quot; the current value saved in id.
      // The out port on the `id` component always shows the last saved
      // element. We don't need to set the `go` because we're not executing
      // and control.
      current_value.in = id.out;
      current_value.write_en = 1'd1;
      use_id[done] = current_value.done;
    }
  }
  control {
    seq { run_id; use_id; }
  }
}
</code></pre>
<p>Our first group executes the component by setting the <code>go</code> signal for the
component to high and placing the value <code>10</code> on the input port.
The second group simply saves the value on the output port. Importantly,
we don't have to set the <code>go</code> signal of the component to high because we
don't need to save a new value into it.
The component executes the two groups in-order.</p>
<p>To see the output from running this component, run the command:</p>
<pre><code>fud e examples/futil/multi-component.futil --to vcd_json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-memories-by-reference"><a class="header" href="#passing-memories-by-reference">Passing Memories by Reference</a></h1>
<p>One question that may arise when using Calyx as a backend is how to
pass a memory &quot;by reference&quot; between components. In C++, this might look like:</p>
<pre><code>#include &lt;array&gt;
#include &lt;cstdint&gt;

// Adds one to the first element in `v`.
void add_one(std::array&lt;uint32_t, 1&gt;&amp; v) {
  v[0] = v[0] + 1;
}

int main() {
  std::array&lt;uint32_t, 1&gt; x = { 0 };
  add_one(x); // The value at x[0] is now 1.
}
</code></pre>
<p>There are two steps to passing a memory by reference in Calyx:</p>
<ol>
<li>Define the component in a manner such that it can accept a memory by reference.</li>
<li>Pass the desired memory by reference.</li>
</ol>
<p>The language provides two ways to doing this.</p>
<h2 id="the-easy-way"><a class="header" href="#the-easy-way">The Easy Way</a></h2>
<p>Calyx uses the <code>ref</code> keyword to describe cells that are passed in by-reference:</p>
<pre><code>component add_one() -&gt; () {
  cells {
    ref mem = std_mem_d1(32, 4, 3); // A memory passed in by refernece.
    ...
  }
  ...
}
</code></pre>
<p>This component define <code>mem</code> as a memory that is passed in by reference to the component.
Inside the component we can use the cell like any other cell in the program.</p>
<p>Next, to pass the memory to the component, we can use the <code>invoke</code> syntax:</p>
<pre><code>component add_one() -&gt; () { ... }
component main() -&gt; () {
  cells {
    A = std_mem_d1(32, 4, 3); // A memory passed in by refernece.
    one = add_one();
    ...
  }
  wires { ... }
  control {
    invoke one[mem = A]()(); // pass A as the `mem` for this invocation
  }
}
</code></pre>
<p>The Calyx compiler will correctly lower the <code>add_one</code> component and the <code>invoke</code> call such that the memory is passed in by-reference.
In fact, any cell can be passed in by-reference in a Calyx program.
Read the next section if you're curious about how this process is implemented.</p>
<h2 id="the-hard-way"><a class="header" href="#the-hard-way">The Hard Way</a></h2>
<p>In the C++ code above, we've constructed an &quot;l-value reference&quot; to the array,
which essentially means we can both read and write from <code>x</code> in the function
<code>add_one</code>.</p>
<p>Now, let's allow similar functionality at the Calyx IR level.
We define a new component named <code>add_one</code> which represents the function
above. However, we also need to include the correct ports to both read
and write to <code>x</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Read from <code>x</code></th><th>Write to <code>x</code></th></tr></thead><tbody>
<tr><td>read_data</td><td>done</td></tr>
<tr><td>address ports</td><td>write_data</td></tr>
<tr><td></td><td>write_en</td></tr>
<tr><td></td><td>address ports</td></tr>
</tbody></table>
</div>
<p>Since we're both reading and writing from <code>x</code>, we'll
include the union of the columns above:</p>
<pre><code>component add_one(x_done: 1, x_read_data: 32) -&gt;
                 (x_write_data: 32, x_write_en: 1, x_addr0: 1) {
</code></pre>
<p>One tricky thing to note is where the ports belong, i.e. should it be
an input port or an output port of the component? The way to reason about this
is to ask whether we want to receive signal from or send signal to the given wire. For example,
with <code>read_data</code>, we will always be receiving signal from it, so it should be an input port.
Conversely, address ports are used to mark where in memory we want to access,
so those are used as output ports.</p>
<p>We then simply use the given ports to both read and write to the memory passed
by reference. Note that we've split up the read and write to memory <code>x</code> in separate groups,
to ensure we can schedule them sequentially in the execution flow.
We're also using the exposed ports of the memory through the component interface rather than,
say, <code>x.write_data</code>.</p>
<pre><code>    group read_from_x {
      x_addr0 = 1'd0;            // Set address port to zero.
      tmp_reg.in = x_read_data;  // Read the value at address zero.
      tmp_reg.write_en = 1'd1;
      read_from_x[done] = tmp_reg.done;
    }
    group write_to_x {
      x_addr0 = 1'd0;            // Set address port to zero.
      add.left = one.out;
      add.right = tmp_reg.out;   // Saved value from previous read.

      x_write_data = add.out;    // Write value to address zero.
      x_write_en = 1'd1;         // Set write enable signal to high.

      write_to_x[done] = x_done; // The group is done when the write is complete.
    }
</code></pre>
<p>Bringing everything back together, the <code>add_one</code> component is written accordingly:</p>
<pre><code>component add_one(x_done: 1, x_read_data: 32) -&gt;
                 (x_write_data: 32, x_write_en: 1, x_addr0: 1) {
  cells {
    one = std_const(32, 1);
    add = std_add(32);
    tmp_reg = std_reg(32);
  }
  wires {
    group read_from_x {
      x_addr0 = 1'd0;            // Set address port to zero.
      tmp_reg.in = x_read_data;  // Read the value at address zero.
      tmp_reg.write_en = 1'd1;
      read_from_x[done] = tmp_reg.done;
    }
    group write_to_x {
      x_addr0 = 1'd0;            // Set address port to zero.
      add.left = one.out;
      add.right = tmp_reg.out;   // Saved value from previous read.

      x_write_data = add.out;    // Write value to address zero.
      x_write_en = 1'd1;         // Set write enable signal to high.

      write_to_x[done] = x_done; // The group is done when the write is complete.
    }
  }
  control {
    seq { read_from_x; write_to_x; }
  }
}
</code></pre>
<p>The final step is creating a <code>main</code> component from which the original component
will be invoked. In this step, it is important to hook up the proper wires in the
call to <code>invoke</code> to the corresponding memory you'd like to read and/or write to:</p>
<pre><code>  control {
    invoke add_one0(x_done = x.done, x_read_data = x.read_data)
                   (x_write_data = x.write_data, x_write_en = x.write_en, x_addr0 = x.addr0);
  }
</code></pre>
<p>This gives us the <code>main</code> component:</p>
<pre><code>component main() -&gt; () {
  cells {
    add_one0 = add_one();
    @external(1) x = std_mem_d1(32, 1, 1);
  }
  wires {
  }
  control {
    invoke add_one0(x_done = x.done, x_read_data = x.read_data)
                   (x_write_data = x.write_data, x_write_en = x.write_en, x_addr0 = x.addr0);
  }
}
</code></pre>
<p>To see this example simulated, run the command:</p>
<pre><code>fud e examples/futil/memory-by-reference/memory-by-reference.futil --to dat \
-s verilog.data examples/futil/memory-by-reference/memory-by-reference.futil.data
</code></pre>
<h2 id="multi-dimensional-memories"><a class="header" href="#multi-dimensional-memories">Multi-dimensional Memories</a></h2>
<p>Not much changes for multi-dimensional arrays. The only additional step is adding
the corresponding address ports. For example, a 2-dimensional memory will require address ports
<code>addr0</code> and <code>addr1</code>. More generally, an <code>N</code>-dimensional memory will require address ports
<code>addr0</code>, ..., <code>addr(N-1)</code>.</p>
<h2 id="multiple-memories"><a class="header" href="#multiple-memories">Multiple Memories</a></h2>
<p>Similarly, multiple memories will just require the ports to be passed for each of the given memories.
Here is an example of a memory copy (referred to as <code>mem_cpy</code> in the C language), with 1-dimensional memories of size 5:</p>
<pre><code>import &quot;primitives/core.futil&quot;;
component copy(dest_done: 1, src_read_data: 32, length: 3) -&gt;
              (dest_write_data: 32, dest_write_en: 1, dest_addr0: 3, src_addr0: 3) {
  cells {
    lt = std_lt(3);
    N = std_reg(3);
    add = std_add(3);
  }
  wires {
    comb group cond {
      lt.left = N.out;
      lt.right = length;
    }
    group upd_index&lt;&quot;static&quot;=1&gt; {
      add.left = N.out;
      add.right = 3'd1;
      N.in = add.out;
      N.write_en = 1'd1;
      upd_index[done] = N.done;
    }
    group copy_index_N&lt;&quot;static&quot;=1&gt; {
      src_addr0 = N.out;
      dest_addr0 = N.out;
      dest_write_en = 1'd1;
      dest_write_data = src_read_data;
      copy_index_N[done] = dest_done;
    }
  }
  control {
    while lt.out with cond {
      seq {
        copy_index_N;
        upd_index;
      }
    }
  }
}

component main() -&gt; () {
  cells {
    @external(1) d = std_mem_d1(32,5,3);
    @external(1) s = std_mem_d1(32,5,3);
    length = std_const(3, 5);
    copy0 = copy();
  }
  wires {
  }
  control {
    seq {
      invoke copy0(dest_done=d.done, src_read_data=s.read_data, length=length.out)
                  (dest_write_data=d.write_data, dest_write_en=d.write_en, dest_addr0=d.addr0, src_addr0=s.addr0);
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calyx-language-reference"><a class="header" href="#calyx-language-reference">Calyx Language Reference</a></h1>
<h2 id="top-level-constructs"><a class="header" href="#top-level-constructs">Top-Level Constructs</a></h2>
<p>Calyx programs are a sequence of <code>import</code> statements followed by a sequence of
<code>extern</code> statements or <code>component</code> definitions.</p>
<h3 id="import-statements"><a class="header" href="#import-statements"><code>import</code> statements</a></h3>
<p><code>import &quot;&lt;path&gt;&quot;</code> has almost exactly the same semantics to that of <code>include</code> in
C-style programming languages; it copies the code <code>path</code> into the current file.</p>
<h3 id="extern-definitions"><a class="header" href="#extern-definitions"><code>extern</code> definitions</a></h3>
<p><code>extern</code> definitions allow Calyx programs to link against arbitrary RTL code.
An <code>extern</code> definition looks like this:</p>
<pre><code>extern &quot;&lt;path&gt;&quot; {
  &lt;primitives&gt;...
}
</code></pre>
<p><code>&lt;path&gt;</code> should be a valid file system path that points to a Verilog module that
defines the same names as the <em>primitives</em> defined in the <code>extern</code> block.
When run with the <code>-b verilog</code> flag, the calyx compiler will copy the text contained
in every such verilog file into the generated output.</p>
<h3 id="primitive-definitions"><a class="header" href="#primitive-definitions"><code>primitive</code> definitions</a></h3>
<p>The <code>primitive</code> construct allows specification of the signature of an external
Verilog module that the Calyx program uses.
It has the following syntax:</p>
<pre><code>[comb] primitive name&lt;attributes&gt;[PARAMETERS](ports) -&gt; (ports);
</code></pre>
<ul>
<li>The <code>comb</code> primitive is used to signal that the primitive definition wraps purely
combinational RTL code. This is useful for certain optimizations.</li>
<li>The <em>attributes</em> syntax allows specification of useful optimization metadata in
form of <a href="lang/./attributes.html">attributes</a>.</li>
<li><em>PARAMETERS</em> defines the parameters passed to the RTL code.</li>
<li>The <em>ports</em> section contain sized port definitions that can either be positive number
or one of the parameters.</li>
</ul>
<p>For example, the following is the signature of the <code>std_reg</code> primitive from the
Calyx standard library:</p>
<pre><code>  primitive std_reg&lt;&quot;state_share&quot;=1,&quot;static&quot;=1&gt;[WIDTH](
    @write_together(1) in: WIDTH,
    @write_together(1) @go write_en: 1,
    @clk clk: 1,
    @reset reset: 1
  ) -&gt; (
    @stable out: WIDTH,
    @done done: 1
  );
</code></pre>
<p>The primitive defines one parameter called <code>WIDTH</code> which describes the sizes for
the <code>in</code> and the <code>out</code> port.</p>
<h2 id="calyx-components"><a class="header" href="#calyx-components">Calyx Components</a></h2>
<p><code>components</code> are the primary encapsulation unit of a Calyx program.
They look like this:</p>
<pre><code>component name&lt;attributes&gt;(ports) -&gt; (ports) {
  cells { .. }
  wires { .. }
  control { .. }
}
</code></pre>
<p>Unlike <code>primitive</code> definitions, <code>component</code> definitions cannot be parameterized and
must provide exact port width for all ports.
A component encapsulates the control and the hardware structure needed to implement
a hardware module.</p>
<h3 id="ports"><a class="header" href="#ports"><code>ports</code></a></h3>
<p>Ports defined in Calyx only specify their bitwidth and are otherwise untyped:</p>
<pre><code>component counter(left: 32, right: 32) -&gt; (@stable out0: 32, out1: 32) { .. }
</code></pre>
<p>The component defines two input ports <code>left</code> and <code>right</code> and two output ports
<code>out0</code> and <code>out1</code>.
Additionally, the <code>out0</code> port has the <a href="lang/./attributes.html">attribute</a> <code>@stable</code>.</p>
<h3 id="cells"><a class="header" href="#cells"><code>cells</code></a></h3>
<p>The <code>cells</code> section of the Calyx program instantiates all the sub-component used
by this component.
For example, the following definition of the <code>counter</code> component instantiates a
<code>std_add</code> and <code>std_reg</code> primitive as well as a <code>foo</code> calyx component</p>
<pre><code>component foo() -&gt; () { .. }
component counter() -&gt; () {
  cells {
    r = std_reg(32);
    a = std_add(32);
    f = foo();
  }
  wires { .. }
  control { .. }
}
</code></pre>
<p>When instantiating a <code>primitive</code> definition, the parameter are passed within the
parenthesis.
For example, we pass <code>32</code> for the <code>WIDTH</code> parameter of the <code>std_reg</code> in the above
instantiation.
Since an instantiation of a calyx component does not take any parameters, the parameters
are always empty.</p>
<h2 id="the-wires-section"><a class="header" href="#the-wires-section">The <code>wires</code> Section</a></h2>
<p>A component's <code>wires</code> section is a sequence of guarded assignments, <code>group</code> definitions, or <code>comb group</code> definitions.</p>
<h3 id="continuous-assignments"><a class="header" href="#continuous-assignments">Continuous assignments</a></h3>
<p>Assignments connect ports between two cells together:</p>
<pre><code>r.in = add.out;
</code></pre>
<p>The above assignment <em>continuously</em> transfer the value in <code>add.out</code> to <code>r.in</code>.</p>
<p>Because assignments are <em>continuous</em>, their order does not matter:</p>
<pre><code>r.in = add.out;
add.left = y.out;
</code></pre>
<p>Assignments can additionally be guarded using a 1-bit value:</p>
<pre><code>r.in = cond.out ? add.out;
r.in = !cond.out ? 32'd0;
</code></pre>
<p>Guards allow specification of multiple different values to a port.</p>
<blockquote>
<p><strong>Well-formedness</strong>: For each input port on the LHS, only one guard should be active in any given cycle during the execution of a Calyx program.</p>
</blockquote>
<p>When an assignment is directly placed into a component's <code>wires</code> section, it
is called a &quot;continuous assignment&quot; and is permanently active, even when the
<a href="lang/ref.html#the-control-operators">control program</a> of the component is inactive.</p>
<h3 id="group-definitions"><a class="header" href="#group-definitions"><code>group</code> definitions</a></h3>
<p>A <code>group</code> is a way to name a set of assignments that together represent some
meaningful action:</p>
<pre><code>group name&lt;attributes&gt; {
  assignments...
  name[done] = done_cond;
}
</code></pre>
<p>Assignments within a group can be reasoned about in isolation from assignments
in other groups.
These means that seemingly conflicting writes to the same ports are allowed:</p>
<pre><code>group foo {
  r.in = 32'd10; ..
  foo[done] = ..
}
group bar {
  r.in = 32'd22; ..
  bar[done] = ..
}
</code></pre>
<p>This is because group only execute when they are mentioned in the <a href="lang/ref.html#the-control-operators">control program</a>.</p>
<p>However, group assignments are not allowed to conflict with <a href="lang/ref.html#continuous-assignments">continuous assignments</a> defined in the component:</p>
<pre><code>group foo {
  r.in = 32'd10; .. // This is malformed because it conflicts with the write below
  foo[done] = ..
}
r.in = 32'd50;
</code></pre>
<p>The <code>done</code> condition of a group is any 1-bit port that, when set to 1, represents the completion of a group's execution.
This is because groups can take any number of cycles and therefore need a way
to specify to the external world when their execution has completed.</p>
<p>The attributes syntax specifies the attributes for the group.</p>
<blockquote>
<p><strong>Well-formedness</strong>: All groups are required to run for at least one cycle.</p>
</blockquote>
<h3 id="comb-group-definitions"><a class="header" href="#comb-group-definitions"><code>comb group</code> definitions</a></h3>
<p>Combinational groups are a restricted version of groups which perform their
computation purely combinationally and therefore run for &quot;less than one cycle&quot;:</p>
<pre><code>comb group name&lt;attributes&gt; {
  assignments..
}
</code></pre>
<p>Because their computation is required to run for less than a cycle, <code>comb group</code>
definitions do not specify a <code>done</code> condition.</p>
<p>Combinational groups cannot be used within normal <a href="lang/ref.html#the-control-operators">control
operators</a>.
Instead, they only occur after the <code>with</code> keyword in a control program.</p>
<h2 id="the-control-operators"><a class="header" href="#the-control-operators">The Control Operators</a></h2>
<p>The <code>control</code> section of a component contains a control program built-up using
the following operators:</p>
<h3 id="group-enable"><a class="header" href="#group-enable">Group enable</a></h3>
<p>Simply naming a group in a control statement, called a group enable, executes
the group to completion.
This is a leaf node in the control program.</p>
<h3 id="invoke"><a class="header" href="#invoke"><code>invoke</code></a></h3>
<p><code>invoke</code> acts like the function call operator for Calyx and has the following
syntax:</p>
<pre><code>invoke instance[ref cells](inputs)(outputs) [with comb_group];
</code></pre>
<ul>
<li><code>instance</code> is the name of the cell instance that needs to be invoked.</li>
<li><code>inputs</code> and <code>outputs</code> define connections for a subset of input and output
ports of the instance.</li>
<li>The <code>with comb_group</code> section is optional and names a <a href="lang/ref.html#comb-group">combinational
group</a> that is active during the execution of the <code>invoke</code>
statement.</li>
<li>The <a href="lang/ref.html#ref-cells"><code>ref cells</code></a> syntax is described in detail</li>
</ul>
<p>Invoking a instance runs its control program to completion before returning.
Any Calyx component or primitive that implements the <a href="lang/ref.html#the-go-done-interface">go-done interface</a> can be invoked.</p>
<h3 id="seq"><a class="header" href="#seq"><code>seq</code></a></h3>
<p>The syntax is:</p>
<pre><code>seq { c1; .. cn; }
</code></pre>
<p>Sequences run the control programs, <code>c1</code>..<code>cn</code> in sequence, guaranteeing that
each program runs fully before the next one starts executing.
<code>seq</code> <strong>does not</strong> provide any cycle-level guarantees on when a succeeding
group starts executing.</p>
<h3 id="par"><a class="header" href="#par"><code>par</code></a></h3>
<p>The syntax is:</p>
<pre><code>par { c1; .. cn; }
</code></pre>
<p>Parallel runs the control programs, <code>c1</code>..<code>cn</code> in parallel, guaranteeing that
each program only runs once.
<code>par</code> <strong>does not</strong> provide any guarantees on how the execution of child programs
is scheduled.
It is therefore not safe to assume that all children begin execution at the
same time.</p>
<blockquote>
<p><strong>Well-formedness</strong>: The assignments in the children <code>c1</code>..<code>cn</code> should never conflict with each other.</p>
</blockquote>
<h3 id="if"><a class="header" href="#if"><code>if</code></a></h3>
<p>The syntax is:</p>
<pre><code>if &lt;port&gt; [with comb_group] {
  true_c
} else {
  false_c
}
</code></pre>
<p>The conditional execution runs either <code>true_c</code> or <code>false_c</code> using the value of
<code>&lt;port&gt;</code>.
The optional <code>with comb_group</code> syntax allows running a combinational group
that computes the value of the port.</p>
<blockquote>
<p><strong>Well-formedness</strong>: The combinational group is considered to be running during the entire execution
of the control program and therefore should not have conflicting assignments
with either <code>true_c</code> or <code>false_c</code>.</p>
</blockquote>
<h3 id="while"><a class="header" href="#while"><code>while</code></a></h3>
<p>The syntax is:</p>
<pre><code>while &lt;port&gt; [with comb_group] {
  body_c
}
</code></pre>
<p>Repeatedly executes <code>body_c</code> while the value on <code>port</code> is non-zero.
The optional <code>with comb_group</code> enables a combinational group that computes the
value of <code>port</code>.</p>
<blockquote>
<p><strong>Well-formedness</strong>: The combinational group is considered active during the execution of the while
loop and therefore should not have conflicting assignments with <code>body_c</code>.</p>
</blockquote>
<h2 id="the-go-done-interface"><a class="header" href="#the-go-done-interface">The <code>go</code>-<code>done</code> Interface</a></h2>
<p>By default, calyx components implement a one-sided ready-valid interface called
the <code>go</code>-<code>done</code> interface.
During compilation, the Calyx compiler will add an input port marked with the attribute <code>@go</code> and an output port marked with the attribute <code>@done</code> to the interface of the component:</p>
<pre><code>component counter(left: 32, right: 32, @go go: 1) -&gt; (out: 32, @done done: 1) ..
</code></pre>
<p>The interface provides a way to trigger the control program of the counter using
assignments.
When the <code>go</code> signal of the component is set to 1, the control program starts
executing.
When the component sets the <code>done</code> signal to 1, its control program has finished
executing.</p>
<blockquote>
<p><strong>Well-formedness</strong>: The <code>go</code> signal to the component must remain set to 1 while the done signal is not 1. Lowering the <code>go</code> signal before the <code>done</code> signal is set to 1 will lead to undefined behavior.</p>
</blockquote>
<h2 id="the-clk-and-reset-ports"><a class="header" href="#the-clk-and-reset-ports">The <code>clk</code> and <code>reset</code> Ports</a></h2>
<p>The compiler also adds special input ports marked with <code>@clk</code> and <code>@reset</code> to the
interface.
By default, the Calyx components are not allowed to look at, or use these signal.
They are automatically threaded to any primitive that defines <code>@clk</code> or
<code>@reset</code> ports.</p>
<h2 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h2>
<h3 id="ref-cells"><a class="header" href="#ref-cells"><code>ref</code> cells</a></h3>
<p><strong>TK</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="experimental-synchronization"><a class="header" href="#experimental-synchronization">Experimental: Synchronization</a></h1>
<p>Calyx's default semantics <a href="lang/./undefined.html#semantics-of-par">do not admit</a> any predictable form of language-level
synchronization in presence of parallelism.
We're currently experimenting with a suite of new primitives that add synchronization to the
language.</p>
<h2 id="std_sync_reg"><a class="header" href="#std_sync_reg"><code>std_sync_reg</code></a></h2>
<p>The <code>std_sync_reg</code> primitive defined by <code>primitives/sync.futil</code> provides a synchronizing
register that acts as an <a href="http://composition.al/blog/2013/09/22/some-example-mvar-ivar-and-lvar-programs-in-haskell/">M-structure</a> which provides the following interface:
On the reader side:</p>
<ol>
<li>If the register is &quot;empty&quot;, block the read till the register is written into.</li>
<li>If the register is &quot;full&quot;, provide the value to the reader, provide a <code>done</code> signal, and mark it as &quot;empty&quot;.</li>
</ol>
<p>On the writer side:</p>
<ol>
<li>If the register is &quot;empty&quot;, write the value in the register, mark it as &quot;full&quot;, and provide a <code>done</code> signal.</li>
<li>If the register is &quot;full&quot;, block the write till the register is read from.</li>
</ol>
<p>One way to think of this interface is as a size-1 concurrent FIFO.</p>
<h2 id="using-std_sync_reg"><a class="header" href="#using-std_sync_reg">Using <code>std_sync_reg</code></a></h2>
<blockquote>
<p>The <a href="https://github.com/cucapra/calyx/blob/master/examples/sync/sync.futil">following example</a> is a part of the Calyx compiler test suite and can be
executed using:</p>
<pre><code>  runt -i examples/sync
</code></pre>
</blockquote>
<p>The synchronizing register interface is non-standard: it provides two go signals and
two done signals to initiate parallel reads and writes.</p>
<pre><code>  primitive std_sync_reg[WIDTH](
    @write_together(1) in_0: WIDTH,
    @write_together(2) in_1: WIDTH,
    read_en_0: 1,
    read_en_1: 1, 
    @write_together(1) write_en_0: 1,
    @write_together(2) write_en_1: 1,
    @clk clk: 1,
    @reset reset: 1
  ) -&gt; (
    out_0: WIDTH,
    out_1: WIDTH,
    write_done_0: 1,
    write_done_1: 1,
    read_done_0: 1,
    read_done_1: 1,
    peek: WIDTH
  );
</code></pre>
<p>The signal <code>read_en</code> is used by a program to initiate a read operation while
the <code>write_en</code> signal initiates a write operation.
We need to explicitly initiate a read operation because reading a value marks
the register as &quot;empty&quot; which causes any future reads to block.</p>
<p>Similarly, the output interface specifies the <code>read_done</code> and <code>write_done</code> signals
which the user program needs to read to know when the operations are completed.
The <code>read_done</code> signal is similar to a <code>valid</code> signal while the <code>write_done</code> is
similar to a <code>write_done</code> signal.</p>
<p>The following group initiates a write operation into the synchronizing register <code>imm</code>
from the memory <code>in</code>:</p>
<pre><code>    // Write value from `in[idx]` to sync intermediate.
    group write_imm {
      imm.write_en_0 = 1'd1;
      imm.in_0 = in.read_data;
      in.addr0 = idx.out;
      write_imm[done] = imm.write_done_0;
    }
</code></pre>
<p>The group waits for the <code>imm.write_done</code> signal to be high before continuing
execution.
If the synchronizing register was &quot;full&quot; in this cycle, the execution would
stall and cause the group to take another cycle.</p>
<p>The following group initiates a read the synchronizing register <code>imm</code> and saves
the value into the <code>out</code> memory:</p>
<pre><code>    // Read value from sync intermediate and write to temp.
    group read_imm {
      imm.read_en_0 = 1'd1;
      out.write_en = imm.read_done_0;
      out.addr0 = idx.out;
      out.write_data = imm.out_0;
      read_imm[done] = out.done;
    }
</code></pre>
<p>The group waits till the <code>imm.read_done</code> signal is high to write the value into
the memory.
Note that in case the register is empty, <code>imm.read_done</code> will be low and cause
the group to another cycle.</p>
<p>Finally, we can describe the control program as:</p>
<pre><code>    while lt.out with cmp {
      seq {
        par {
          read_imm;
          write_imm;
        }
        incr_idx;
      }
    }
</code></pre>
<p>Note that the two groups execute in parallel which means there is no guarantee
to their order of execution.
However, the synchronization ensures that the reads see a consistent set of
writes in the order we expect.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The example above implements a standard producer-consumer.
However, as implemented, the <code>std_sync_reg</code> primitive does not support multiple
producers or consumers.
To do so, it would need to provide an interface that allows several read and
write ports and ensure that only one read or write operation succeeds.
This capability would be useful in implementing synchronizing barriers in Calyx.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>Calyx has an attribute system that allows information to be associated with
every basic Calyx construct. This information can then be used to optimize the program
or change how the program is compiled.</p>
<p>Attributes can decorate lots of things in Calyx: components, groups, cells, ports, and control statements.
The syntax looks like <code>name&lt;&quot;attr&quot;=value&gt;</code> for components and groups or <code>@attr(value)</code> for other constructs.
Attributes always map keys to values.
Because it's common to have a &quot;Boolean&quot; attribute that always maps to the value 1, the syntax <code>@attr</code> is a shorthand for <code>@attr(1)</code>.</p>
<p>Here is the syntax for attributes in different parts of the AST:</p>
<h4 id="component-and-port-attributes"><a class="header" href="#component-and-port-attributes"><strong>Component and Port Attributes</strong></a></h4>
<pre><code>component main&lt;&quot;static&quot;=10&gt;(@go go: 1) -&gt; (@done done: 1) {
 ...
}
</code></pre>
<h4 id="cell-attributes"><a class="header" href="#cell-attributes"><strong>Cell Attributes</strong></a></h4>
<pre><code>cells {
  @external mem = std_mem_d1(32, 8, 4);
  reg = std_reg(32);
  ...
}
</code></pre>
<h4 id="group-attributes"><a class="header" href="#group-attributes"><strong>Group Attributes</strong></a></h4>
<pre><code>group cond&lt;&quot;static&quot;=1&gt; {
  ...
}
</code></pre>
<h4 id="control-attributes"><a class="header" href="#control-attributes"><strong>Control Attributes</strong></a></h4>
<pre><code>control {
  @static(3) seq {
    @static(1) A;
    @static(2) B;
  }
}
</code></pre>
<h2 id="meaning-of-attributes"><a class="header" href="#meaning-of-attributes">Meaning of Attributes</a></h2>
<h3 id="toplevel"><a class="header" href="#toplevel"><code>toplevel</code></a></h3>
<p>The entrypoint for the Calyx program. If no component has this attribute, then
the compiler looks for a component named <code>main</code>. If neither is found, the
compiler errors out.</p>
<h3 id="go-done-clk-and-reset"><a class="header" href="#go-done-clk-and-reset"><code>go</code>, <code>done</code>, <code>clk</code> and <code>reset</code></a></h3>
<p>These four ports are part of the interface to Calyx components.
These are automatically added by the parser if they are missing from the component definition.
<code>go</code> and <code>done</code> provide the mechanism for how an &quot;outer&quot; component invokes an &quot;inner&quot; cell that it contains.
<code>clk</code> and <code>reset</code> thread through the global clock and resetting signal in a design.</p>
<h3 id="nointerface"><a class="header" href="#nointerface"><code>nointerface</code></a></h3>
<p>By default, interface ports are automatically added to a component by the parser if they are missing.
Adding this attribute disables this behavior.</p>
<h3 id="external"><a class="header" href="#external"><code>external</code></a></h3>
<p>The <code>external</code> attribute has meaning when it is attached to a cell.
It has two meanings:</p>
<ol>
<li>If the <code>externalize</code> pass is enabled, the cell is turned into an &quot;external&quot;
cell by exposing all its ports through the current component and rewriting
assignments to the use the ports. See the documentation on
See <a href="https://docs.calyxir.org/source/calyx/passes/struct.Externalize.html" title="Externalize Pass">externalize</a> for more information.</li>
<li>If the cell is a memory and has an <code>external</code> attribute on it, the verilog backend (<code>-b verilog</code>) generates code to read <code>&lt;cell_name&gt;.dat</code> to initialize the memory state and dumps out its final value after execution.</li>
</ol>
<h3 id="staticn"><a class="header" href="#staticn"><code>static(n)</code></a></h3>
<p>Can be attached to components, groups, and control statements. They indicate how
many cycles a component, group, or control statement will take to run and are used
by <code>-p static-timing</code> to generate more efficient control FSMs.</p>
<p>The <code>go</code> and <code>done</code> attributes are, in particular, used by the <code>infer-static-timing</code> pass to configure which ports are used like
<code>go</code> and <code>done</code> signals.
Along with the <code>static(n)</code> attribute, this allows the pass to calculate when
a particular done signal of a primitive will be high.</p>
<h3 id="inline"><a class="header" href="#inline"><code>inline</code></a></h3>
<p>Used by the <code>inline</code> pass on cell definitions. Instructs the pass to completely
inline the instance into the parent component and replace all <code>invoke</code>s of the
instance with the control program of the instance.</p>
<h3 id="stable"><a class="header" href="#stable"><code>stable</code></a></h3>
<p>Used by the <code>canonicalize</code> pass.
Only meaningful on output ports and states that their value is provided by
a sequential element and is therefore available outside combinational time.</p>
<p>For example, after invoking a multiplier, the value on its <code>out</code> port remains
latched till the next invocation.</p>
<p>For example</p>
<pre><code>cells {
  m = std_mult_pipe(32);
}
wires {
  group use_m_out { // uses m.out }
}
control {
  invoke m(left = 32'd10, right = 32'd4)();
  use_m_out;
}
</code></pre>
<p>The value of <code>m.out</code> in <code>use_m_out</code> will be <code>32'd40</code>.</p>
<p>This annotation is currently used by the primitives library and the Dahlia
frontend.</p>
<h3 id="share"><a class="header" href="#share"><code>share</code></a></h3>
<p>Can be attached to a component and indicates that a component can be shared
across groups. This is used by the <code>-p resource-sharing</code> to decide which components
can be shared.</p>
<h3 id="state_share"><a class="header" href="#state_share"><code>state_share</code></a></h3>
<p>Can be attached to a component and indicates that a component can be shared
across groups. Different than <code>share</code> since <code>state_share</code> components can have
internal state.<br />
This is used by <code>-p cell-share</code> to decide which components can be shared.
Specifically, a component is state shareable if each write to 
that component makes any previous writes to the component irrelevant. 
The definition of a &quot;write to a component&quot; is an activiation of 
the component's &quot;go&quot; port, followed by a read of the component's &quot;done&quot; port (in 
other words, the read of a &quot;done&quot; port still counts as part of a &quot;write&quot; to the 
component).
For <code>c1</code> and <code>c2</code>, instances of a state_shareable component:
instantiate <code>c1</code>                        instantiate <code>c2</code>
<em>any write to <code>c1</code></em>                     <em>any write to <code>c2</code></em><br />
<em>write value <code>v</code> to port <code>p</code> in <code>c1</code></em>   <em>write value <code>v</code> to port <code>p</code> in <code>c2</code></em><br />
<code>c1</code> and <code>c2</code> should be equal.</p>
<h3 id="boundn"><a class="header" href="#boundn"><code>bound(n)</code></a></h3>
<p>Used in <code>infer-static-timing</code> and <code>static-timing</code> when the number of iterations
of a <code>While</code> control is known statically, as indicated by <code>n</code>.</p>
<h3 id="generated"><a class="header" href="#generated"><code>generated</code></a></h3>
<p>Added by <a href="https://docs.calyxir.org/source/calyx/ir/struct.Builder.html"><code>ir::Builder</code></a> to denote that the cell was added by a pass.</p>
<h3 id="clk"><a class="header" href="#clk"><code>clk</code></a></h3>
<p>Marks the special clock signal inserted by the <code>clk-insertion</code> pass, which helps with lowering to RTL languages that require an explicit clock.</p>
<h3 id="write_togethern"><a class="header" href="#write_togethern"><code>write_together(n)</code></a></h3>
<p>Used by the <code>papercut</code> pass.
Defines a group <code>n</code> of signals that all must be driven together:</p>
<pre><code>primitive std_mem_d2&lt;&quot;static&quot;=1&gt;[WIDTH, D0_SIZE, D1_SIZE, D0_IDX_SIZE, D1_IDX_SIZE](
  @write_together(2) addr0: D0_IDX_SIZE,
  @write_together(2) addr1: D1_IDX_SIZE,
  @write_together(1) write_data: WIDTH,
  @write_together(1) @go write_en: 1,
  ...
) -&gt; (...);
</code></pre>
<p>This defines two groups.
The first group requires that <code>write_en</code> and <code>write_data</code> signals together
while the second requires that <code>addr0</code> and <code>addr1</code> are driven together.</p>
<p>Note that <code>@write_together</code> specifications cannot encode implication of the
form &quot;if port <code>x</code> is driven then <code>y</code> should be driven&quot;.</p>
<h3 id="read_togethern"><a class="header" href="#read_togethern"><code>read_together(n)</code></a></h3>
<p>Used by <code>papercut</code> and <code>canonicalize</code>.
Defines a combinational path <code>n</code> between a set of an input ports and an output
port.</p>
<pre><code>primitive std_mem_d1&lt;&quot;static&quot;=1&gt;[WIDTH, SIZE, IDX_SIZE](
  @read_together(1) addr0: IDX_SIZE, ...
) -&gt; (
  @read_together(1) read_data: WIDTH, ...
);
</code></pre>
<p>This requires that when <code>read_data</code> is used then <code>addr0</code> must be driven.
Note that each group must have exactly one output port in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="undefined-behaviors"><a class="header" href="#undefined-behaviors">Undefined Behaviors</a></h1>
<p>Undefined behavior in Calyx is either intentional or unintentional. This page tracks the various issues discussing the undefined behaviors that are known to currently exist in Calyx.</p>
<h2 id="interface-signals"><a class="header" href="#interface-signals">Interface Signals</a></h2>
<p>The <code>go</code> and <code>done</code> signals form the two core interface signals in Calyx. Their semantics are baked into the compiler and pervasively used to define the meaning of programs.</p>
<ul>
<li><a href="https://github.com/cucapra/calyx/discussions/651">Isolation and stateful &quot;doneness&quot; (#651)</a></li>
<li><a href="https://github.com/cucapra/calyx/discussions/788">Well-formedness of <code>done</code> signals (#788)</a></li>
</ul>
<h2 id="undriven-ports"><a class="header" href="#undriven-ports">Undriven Ports</a></h2>
<p>Calyx's continuous assignments do not make any static guarantees about which ports need to be driven when. Current efforts attempt to codify <em>when</em> reading from an undriven port is incorrect.</p>
<ul>
<li><a href="https://github.com/cucapra/calyx/discussions/588">Port validity as a first class concept (#588)</a></li>
<li><a href="https://github.com/cucapra/calyx/discussions/922">A few notes on undefinedness (#922)</a></li>
</ul>
<h2 id="semantics-of-par"><a class="header" href="#semantics-of-par">Semantics of <code>par</code></a></h2>
<p><code>par</code> blocks in Calyx represent parallel execution of groups. Currently, there is no clear semantics for interactions between groups executing in parallel. The interpreter implements a form of lockstep semantics that disallows certain forms of concurrent reads and writes while the code generated by the compiler allows for arbitrary communication.</p>
<ul>
<li><a href="https://github.com/cucapra/calyx/discussions/921">On the semantics of <code>par</code> (#921)</a></li>
<li><a href="https://github.com/cucapra/calyx/discussions/932">Formalizing the semantics of <code>par</code> (#932)</a></li>
</ul>
<h2 id="isolation-guarantees"><a class="header" href="#isolation-guarantees">Isolation Guarantees</a></h2>
<p>Calyx groups have a strong isolation guarantee---they must execute for at least one cycle and guarantee that signals inside are not visible after they are done executing.
However, the isolation guarantees for combinational groups, continuous assignments, and <code>with</code> blocks is not clear.</p>
<ul>
<li><a href="https://github.com/cucapra/calyx/discussions/927">Isolation guarantees of combinational groups</a></li>
<li><a href="https://github.com/cucapra/calyx/discussions/934">The <code>with</code> operator</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fud-the-calyx-driver"><a class="header" href="#fud-the-calyx-driver"><code>fud</code>: The Calyx Driver</a></h1>
<p>Working with Calyx involves a lot of command-line tools. For example, an
incomplete yet daunting list of CLI tools used by Calyx is:</p>
<ul>
<li>All the Calyx <a href="fud/./frontends/index.html">frontends</a>.</li>
<li>Calyx compiler and its various command line tools</li>
<li>Verilator, the Verilog simulation framework used to test Calyx-generated designs.</li>
<li>Waveform viewers to see the results of simulation</li>
</ul>
<p><code>fud</code> aims to provide a simple interface for using these toolchains and
executing them in a pipeline. The source for fud is
<a href="https://github.com/cucapra/futil/tree/master/fud">here</a>.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>You need <a href="https://flit.readthedocs.io/en/latest/">Flit</a> to install <code>fud</code>. Install it with <code>pip3 install flit</code>.</p>
<p>You can then install <code>fud</code> with</p>
<pre><code class="language-bash">flit install
</code></pre>
<p>(If using this method to install <code>fud</code>, <code>pip3</code> should be version &gt;= 20)</p>
<p>If you are working on <code>fud</code> itself, you can install it with a symlink with:</p>
<pre><code class="language-bash">flit install --symlink
</code></pre>
<p>You can also install <code>fud</code> with</p>
<pre><code class="language-bash">flit build
pip3 install dist/fud-0.1.0-py3-none-any.whl
</code></pre>
<p>Finally, point <code>fud</code> to the root of the repository:</p>
<pre><code>fud config global.futil_directory &lt;full path to Calyx repository&gt;
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Fud uses a global configuration file to locate tool paths and default values.
To view the configuration, use <code>fud c</code> or <code>fud config</code>.</p>
<p><strong>Check.</strong>
Fud can automatically check if your configuration is valid and can help you set
certain variables. Perform this check with:</p>
<pre><code class="language-bash">fud check
</code></pre>
<p><strong>Viewing keys.</strong>
To view the current value of a key, use <code>fud config key</code>. For example, the
following shows the path to the Calyx compiler.</p>
<pre><code class="language-bash">fud config stages.futil.exec
</code></pre>
<p><strong>Updating keys.</strong>
Keys can be updated using <code>fud config key value</code>.
For example, the following command updates the path to the Calyx compiler.</p>
<pre><code class="language-bash">fud config stages.futil.exec ./target/debug/futil
</code></pre>
<h2 id="adding-backends"><a class="header" href="#adding-backends">Adding Backends</a></h2>
<p><code>fud</code> wraps both frontends and backends for Calyx.
For a useful <code>fud</code> installation, you need to configure the Verilator
backend and accompanying tools.</p>
<h3 id="verilator"><a class="header" href="#verilator">Verilator</a></h3>
<p>We use the open source <a href="https://www.veripool.org/wiki/verilator">Verilator</a> tool to simulate Verilog programs
generated by the Calyx compiler.
Install Verilator by <a href="https://www.veripool.org/projects/verilator/wiki/Installing">following the official instructions</a>.
On macOS, you can use <code>brew install verilator</code> or, otherwise, compile from source:</p>
<pre><code>git clone https://github.com/verilator/verilator
cd verilator
git pull
git checkout master
autoconf
./configure
make
sudo make install
</code></pre>
<p>Run <code>fud check</code> to make sure you have the right version.</p>
<p>By default, <code>fud</code> will use the <code>verilator</code> executable to run Verilator.
To use a different binary, configure the path by:</p>
<pre><code>fud config stages.verilog.exec &lt;binary&gt;
</code></pre>
<p><strong>Vcdump.</strong>
Vcdump is a tool for converting <code>vcd</code> (Value Change Dump) files to JSON for
easier analysis with the command line.</p>
<p>Install it with:</p>
<pre><code class="language-bash">cargo install vcdump
</code></pre>
<h3 id="icarus-verilog"><a class="header" href="#icarus-verilog">Icarus Verilog</a></h3>
<p><code>fud</code> also supports <a href="http://iverilog.icarus.com/">Icarus Verilog</a> as a simulation backend.
Since Icarus Verilog interprets programs, it can often be faster than
<code>verilator</code>.
First <a href="https://iverilog.fandom.com/wiki/Installation_Guide">install Icarus Verilog</a> and ensure that <code>iverilog</code> and
<code>vvp</code> are on your path.
Next, register the <code>icarus-verilog</code> external stage with <code>fud</code>:</p>
<pre><code>fud register icarus-verilog -p fud/icarus/icarus.py
</code></pre>
<p>To test the simulation backend, run:</p>
<pre><code>fud e --to dat examples/tutorial/language-tutorial-iterate.futil -s verilog.data examples/tutorial/data.json --through icarus-verilog
</code></pre>
<p>Registering this stage will define multiple paths in the fud transformation
graph between <code>futil</code> and the <code>vcd</code> and <code>dat</code> stages.
If you'd like <code>fud</code> to default to <code>verilog</code> stage, give it a <a href="fud/./multiple-paths.html#using-stage-priority">high
priority</a>:</p>
<pre><code>fud c stages.verilog.priority 1
</code></pre>
<h2 id="dahlia-frontend"><a class="header" href="#dahlia-frontend">Dahlia Frontend</a></h2>
<p>In order to use the Dahlia frontend with Fud, first <a href="fud/../frontends/dahlia.html">install
Dahlia</a>.
Once Dahlia is compiled, point <code>fud</code> to the Dahlia compiler binary:</p>
<pre><code class="language-bash">fud config stages.dahlia.exec &lt;full path to dahlia repo&gt;/fuse
</code></pre>
<h2 id="python-frontends-systolic-array-ntt-mrxl-tvm-relay"><a class="header" href="#python-frontends-systolic-array-ntt-mrxl-tvm-relay">Python frontends (Systolic array, NTT, MrXL, TVM Relay)</a></h2>
<p>You need <a href="https://flit.readthedocs.io/en/latest/">flit</a> to install our Python frontends.</p>
<pre><code>pip3 install flit
</code></pre>
<p>Our Python <a href="fud/../frontends">frontends</a> use a Calyx ast library written in Python. Install with:</p>
<pre><code>cd calyx-py &amp;&amp; flit install -s
</code></pre>
<p>Frontend specific instructions:</p>
<ul>
<li><a href="fud/../frontends/systolic-array.html">Systolic array</a>: Nothing else needed.</li>
<li><a href="fud/../frontends/ntt.html">NTT</a>:
<ul>
<li>Install dependencies: <code>pip3 install prettytable</code></li>
<li>Install external <code>fud</code> stage: <code>fud register ntt -p frontends/ntt-pipeline/fud/ntt.py</code></li>
</ul>
</li>
<li><a href="fud/../frontends/mrxl.html">MrXL</a>:
<ul>
<li>Install <code>mrxl</code> binary: <code>cd frontends/mrxl &amp;&amp; flit install -s</code></li>
<li>Install <code>mrxl</code> <a href="fud/./external.html">external stage</a> for <code>fud</code>: <code>fud register mrxl -p frontends/mrxl/fud/mrxl.py</code></li>
</ul>
</li>
<li><a href="fud/../frontends/tvm-relay.html">TVM Relay</a>: See instructions.</li>
</ul>
<h2 id="adding-synthesis-backends"><a class="header" href="#adding-synthesis-backends">Adding Synthesis Backends</a></h2>
<p><code>fud</code> supports wraps the Vivado (<code>synth-verilog</code>) and Vivado HLS (<code>vivado-hls</code>)
tools to generate area and resource estimates for Calyx designs.
See <a href="fud/./synthesis.html">the instructions</a> to configure them.</p>
<h2 id="working-with-stages"><a class="header" href="#working-with-stages">Working with Stages</a></h2>
<p>Fud is structured as a sequence of stages that transform inputs of one form
to outputs.</p>
<p><strong>Stages.</strong>
<code>fud</code> transforms a file in one stage into a file in a later stage.
The <code>--from</code> and <code>--to</code> options specify the input and output stages to the
<code>fud exec</code> subcommand.
Use <code>fud info</code> to view all possible stages.</p>
<p><strong>Guessing stages.</strong>
<code>fud</code> will try to guess the starting stage by looking at the extension of the
input file and output file (if specified using the <code>-o</code> flag).
If it fails to guess correctly or doesn't know about the extension, you can
manually set the stages using <code>--to</code> and <code>--from</code>.</p>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<p>Fud provides some very basic profiling tools through the use of the <code>--dump_prof</code> (or <code>-pr</code>) flag.
You can get overall stage durations for a <code>fud</code> run by simply using <code>-pr</code>.
For example, </p>
<pre><code class="language-bash">  fud e examples/dahlia/dot-product.fuse --to dat \
  -s verilog.data examples/dahlia/dot-product.fuse.data \
  -pr
</code></pre>
<p>will output:</p>
<pre><code>stage                           elapsed time (s)
dahlia                          1.231
futil                           0.029
verilog                         4.915
</code></pre>
<p>If you want time elapsed for each step in a stage, you can also provide one or more stages after the flag.
For example,</p>
<pre><code class="language-bash">  fud e examples/dahlia/dot-product.fuse --to dat \
  -s verilog.data examples/dahlia/dot-product.fuse.data \
  -pr verilog
</code></pre>
<p>will output:</p>
<pre><code>verilog                         elapsed time (s)
mktmp                           0.0
json_to_dat                     0.004
compile_with_verilator          5.584
simulate                        0.161
output_json                     0.003
cleanup                         0.003
</code></pre>
<p>If you want time elapsed for a single step, you can specify the given step, e.g.</p>
<pre><code class="language-bash">  fud e examples/dahlia/dot-product.fuse --to dat \
  -s verilog.data examples/dahlia/dot-product.fuse.data \
  -pr verilog.simulate
</code></pre>
<p>will output:</p>
<pre><code>verilog                         elapsed time (s)
simulate                        0.161
</code></pre>
<p>Lastly, the <code>-csv</code> flag will provide the profiling information in CSV format.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>These commands will assume you're in the root directory of the Calyx
repository.</p>
<p><strong>Compiling Calyx.</strong>
Fud wraps the Calyx compiler and provides a set of default compiler options
to compile Calyx programs to Verilog.</p>
<pre><code class="language-bash"># Compile Calyx source in the test simple.expect
# to Verilog. We must explicitly specify the input
# file type because it can not be guessed from
# the file extension.
fud exec examples/futil/simple.expect --from futil --to verilog
</code></pre>
<p>Fud can explain its execution plan when running a complex sequence of
steps using the <code>--dry-run</code> option.</p>
<pre><code class="language-bash"># Dry run of compiling the Dahlia dot product file
# to Calyx. As expected, this will *only* print
# the stages that will be run.
fud exec examples/dahlia/dot-product.fuse --to futil --dry-run
</code></pre>
<p><strong>Simulating Calyx.</strong>
Fud can compile a Calyx program to Verilog and simulate it using Verilator.</p>
<pre><code class="language-bash"># Compile and simulate a vectorized add implementation
# in Calyx using the data provided,
# then dump the vcd into a new file for debugging.
# === Calyx:   examples/futil/vectorized-add.futil
# === data:    examples/dahlia/vectorized-add.fuse.data
# === output:  v-add.vcd
fud exec \
  examples/futil/vectorized-add.futil \
  -o v-add.vcd \
  -s verilog.data examples/dahlia/vectorized-add.fuse.data
</code></pre>
<p><strong>Simulating Dahlia.</strong>
The following command prints out the final state of all memories by specifying
<code>--to dat</code>.</p>
<pre><code class="language-bash"># Compile a Dahlia dot product implementation and
# simulate in verilog using the data provided.
# === Dahlia: examples/dahlia/dot-product.fuse
# === data:   examples/dahlia/dot-product.fuse.data
#     (`.data` is used as an extension alias for `.json`)
fud exec \
  examples/dahlia/dot-product.fuse \
  --to dat \
  -s verilog.data examples/dahlia/dot-product.fuse.data
</code></pre>
<p><strong>Interpreting Calyx.</strong>
In addition to Verilator, fud can execute Calyx programs using the experimental <a href="fud/../interpreter.html">interpreter</a>.</p>
<pre><code class="language-bash"># Execute a Calyx program without compiling it,
# producing a JSON snapshot of the final state.
# === Calyx:   tests/correctness/while.futil
# === data:    tests/correctness/while.futil.data
fud exec \
  tests/correctness/while.futil \
  -s verilog.data tests/correctness/while.futil.data \
  --to interpreter-out
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xilinx-toolchain"><a class="header" href="#xilinx-toolchain">Xilinx Toolchain</a></h1>
<blockquote>
<p>Working with vendor EDA toolchains is never a fun experience. Something will
almost certainly go wrong. If you're at Cornell, you can at least avoid
installing the tools yourself by using our lab servers, <a href="https://capra.cs.cornell.edu/private/gorgonzola.html">Gorgonzola</a> or <a href="https://capra.cs.cornell.edu/private/havarti.html">Havarti</a>.</p>
</blockquote>
<p><code>fud</code> can interact with the Xilinx tools (<a href="https://www.xilinx.com/products/design-tools/vivado.html">Vivado</a>, <a href="https://www.xilinx.com/products/design-tools/vivado/integration/esl-design.html">Vivado HLS</a>, and <a href="https://www.xilinx.com/products/design-tools/vitis/vitis-platform.html">Vitis</a>). There are three main things it can do:</p>
<ul>
<li>Synthesize Calyx-generated RTL designs to collect area and resource estimates.</li>
<li>Compile <a href="https://capra.cs.cornell.edu/dahlia/">Dahlia</a> programs via C++ and <a href="https://www.xilinx.com/products/design-tools/vivado/integration/esl-design.html">Vivado HLS</a> for comparison with the Calyx backend.</li>
<li>Compile Calyx programs for <em>actual execution</em> in Xilinx emulation modes or on real FPGA hardware.</li>
</ul>
<p>You can set <code>fud</code> up to use either a local installation of the Xilinx tools or one on a remote server, via SSH.</p>
<h2 id="synthesis-only"><a class="header" href="#synthesis-only">Synthesis Only</a></h2>
<p>The simplest way to use the Xilinx tools is to synthesize RTL or HLS designs to collect statistics about them.
This route will not produce actual, runnable executables; see the next section for that.</p>
<h3 id="installing-dependencies"><a class="header" href="#installing-dependencies">Installing Dependencies</a></h3>
<p><code>fud</code> uses extra dependencies to invoke the Xilinx toolchains.
Run the following command to install all required dependencies:</p>
<pre><code>cd fud &amp;&amp; flit install -s --deps all
</code></pre>
<h3 id="set-up"><a class="header" href="#set-up">Set Up</a></h3>
<p>To set up to <strong>invoke the Xilinx tools over SSH</strong>, first tell <code>fud</code> your username and hostname for the server:</p>
<pre><code># Vivado
fud config stages.synth-verilog.ssh_host &lt;hostname&gt;
fud config stages.synth-verilog.ssh_username &lt;username&gt;
fud config stages.synth-verilog.remote true

# Vivado HLS
fud config stages.vivado-hls.ssh_host &lt;hostname&gt;
fud config stages.vivado-hls.ssh_username &lt;username&gt;
fud config stages.vivado-hls.remote true
</code></pre>
<p>The server must have <code>vivado</code> and <code>vivado_hls</code> available on the remote machine's path. (If you need the executable names to be something else, please file an issue.)</p>
<p>To instead <strong>invoke the Xilinx tools locally</strong>, just let <code>fud</code> run the <code>vivado</code> and <code>vivado_hls</code> commands.
You can optionally tell <code>fud</code> where these commands exist on your machine:</p>
<pre><code>fud config stages.synth-verilog.exec &lt;path&gt; # update vivado path
fud config stages.vivado-hls.exec &lt;path&gt; # update vivado_hls path
</code></pre>
<p>Leave the <code>remote</code> option unset to use local execution and these <code>exec</code> paths (which are ignored for remote execution).</p>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p>To run the entire toolchain and extract statistics from RTL synthesis, use the <code>resource-estimate</code> target state.
For example:</p>
<pre><code>fud e --to resource-estimate examples/futil/dot-product.futil
</code></pre>
<p>To instead obtain the raw synthesis results, use <code>synth-files</code>.</p>
<p>To run the analogous toolchain for Dahlia programs via HLS, use the <code>hls-estimate</code> target state:</p>
<pre><code>fud e --to hls-estimate examples/dahlia/dot-product.fuse
</code></pre>
<p>There is also an <code>hls-files</code> state for the raw results of Vivado HLS.</p>
<h2 id="emulation-and-execution"><a class="header" href="#emulation-and-execution">Emulation and Execution</a></h2>
<p><code>fud</code> can also compile Calyx programs for actual execution, either in the Xilinx toolchain's emulation modes or for running on a physical FPGA.
This route involves generating an <a href="https://en.wikipedia.org/wiki/Advanced_eXtensible_Interface">AXI</a> interface wrapper for the Calyx program and invoking it using <a href="https://xilinx.github.io/XRT/">XRT</a>'s OpenCL interface.</p>
<h3 id="set-up-1"><a class="header" href="#set-up-1">Set Up</a></h3>
<p>As above, you can invoke the Xilinx toolchain locally or remotely, via SSH.
To set up SSH execution, you can edit your <code>config.toml</code> to add settings like this:</p>
<pre><code>[stages.xclbin]
ssh_host = &quot;havarti&quot;
ssh_username = &quot;als485&quot;
remote = true
</code></pre>
<p>To use local execution, just leave off the <code>remote = true</code> line.</p>
<p>You can also set the Xilinx mode and target device:</p>
<pre><code>[stages.xclbin]
mode = &quot;hw_emu&quot;
device = &quot;xilinx_u50_gen3x16_xdma_201920_3&quot;
</code></pre>
<p>The options for <code>mode</code> are <code>hw_emu</code> (simulation) and <code>hw</code> (on-FPGA execution).
The device string above is for the <a href="https://www.xilinx.com/products/boards-and-kits/alveo/u50.html">Alveo U50</a> card, which we have at Cornell. The installed Xilinx card would typically be found under the directory <code>/opt/xilinx/platforms</code>, where one would be able to find a device name of interest.</p>
<p>To use hardware emulation, you will also need to configure the <code>wdb</code> stage.
It has similar <code>ssh_host</code>, <code>ssh_username</code>, and <code>remote</code> options to the <code>xclbin</code> stage.
You will also need to configure the stage to point to your installations of <a href="https://www.xilinx.com/products/design-tools/vitis/vitis-platform.html">Vitis</a> and <a href="https://xilinx.github.io/XRT/">XRT</a>, like this:</p>
<pre><code>[stages.wdb]
xilinx_location: /scratch/opt/Xilinx/Vitis/2020.2
xrt_location: /opt/xilinx/xrt
</code></pre>
<h3 id="compile"><a class="header" href="#compile">Compile</a></h3>
<p>The first step in the Xilinx toolchain is to generate <a href="https://xilinx.github.io/XRT/2021.2/html/formats.html#xclbin">an <code>xclbin</code> executable file</a>.
Here's an example of going all the way from a Calyx program to that:</p>
<pre><code>fud e examples/futil/dot-product.futil -o foo.xclbin --to xclbin
</code></pre>
<p>On our machines, compiling even a simple example like the above for simulation takes about 5 minutes, end to end.
A failed run takes about 2 minutes to produce an error.</p>
<p>By default, the Xilinx tools run in a temporary directory that is deleted when <code>fud</code> finishes.
To instead keep the sandbox directory, use <code>-s xclbin.save_temps true</code>.
You can then find the results in a directory named <code>fud-out-N</code> for some number <code>N</code>.</p>
<h3 id="execute"><a class="header" href="#execute">Execute</a></h3>
<p>Now that you have an <code>xclbin</code>, the next step is to run it.
Roughly speaking, the command you need is just a <code>fud</code> invocation that goes from the <code>xclbin</code> stage to the <code>fpga</code> stage:</p>
<pre><code>fud e foo.xclbin --from xclbin --to fpga -s fpga.data examples/dahlia/dot-product.fuse.data
</code></pre>
<p>Contrary to the name, the <code>fpga</code> stage works for both emulation and on-FPGA execution---fud's <code>mode</code> config option for this stage chooses which to use.
The <code>fpga.data</code> config option provides a normal fud-style JSON data input file for the run.</p>
<p>Currently, you will need to have a bunch of environment variables set up to point to the Xilinx tools <em>before running this fud command</em>.
For example, on our group's havarti server, you can do this:</p>
<pre><code>source /scratch/opt/Xilinx/Vitis/2020.2/settings64.sh
source /opt/xilinx/xrt/setup.sh
export EMCONFIG_PATH=`pwd`
export XCL_EMULATION_MODE=hw_emu
</code></pre>
<p>That is, you'll source the setup scripts for both <a href="https://www.xilinx.com/products/design-tools/vitis/vitis-platform.html">Vitis</a> and <a href="https://xilinx.github.io/XRT/">XRT</a>;
you need to set a special <code>EMCONFIG_PATH</code> to your current directory so that fud can generate a <a href="https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/emconfigutil-Utility">special JSON configuration file for Xilinx emulation</a>;
and you need to tell XRT whether you want <code>hw_emu</code> (emulation) or <code>hw</code> (actual on-device execution) mode.
Of course, it would be better if all this could come from fud's configuration itself instead of requiring you to set it up ahead of time;
<a href="https://github.com/cucapra/calyx/issues/872">issue #872</a> covers this work.</p>
<h4 id="waveform-debugging"><a class="header" href="#waveform-debugging">Waveform Debugging</a></h4>
<p>In emulation mode, this stage can produce a waveform trace in Xilinx's proprietary <a href="https://support.xilinx.com/s/article/64000?language=en_US">WDB</a> file format as well as a standard <a href="https://en.wikipedia.org/wiki/Value_change_dump">VCD</a> file.</p>
<p>Use the fud options <code>-s fpga.waveform true -s fpga.save_temps true</code> when emulating your program.
The first option instructs XRT to use <a href="https://xilinx.github.io/Vitis_Accel_Examples/2021.1/html/debug_profile.html">the <code>batch</code> debug mode</a> and to dump a VCD, and the second asks fud not to delete the directory where the waveform files will appear.</p>
<p>Then, look in the resulting directory, which will be named <code>fud-out-*</code> for some <code>*</code>.
In there, the Xilinx trace files you want are named <code>*.wdb</code> and <code>*.wcfg</code>.
The VCD file is at <code>.run/*/hw_em/device0/binary_0/behav_waveform/xsim/dump.vcd</code> or similar.</p>
<h3 id="emulate"><a class="header" href="#emulate">Emulate</a></h3>
<p>There is also a separate, vestigial path just for doing hardware emulation (i.e., like the <code>hw_emu</code> mode referenced above).
It is probably a bad idea to use this when the <code>fpga</code> stage exists, but it is still available.
Use the <code>wdb</code> state as your <code>fud</code> target:</p>
<pre><code>fud e -vv foo.xclbin -s wdb.save_temps true -o out.wdb
</code></pre>
<p>This stage produces a Vivado <a href="https://support.xilinx.com/s/article/64000?language=en_US">waveform database (WDB) file</a>
Through the magic of <code>fud</code>, you can also go all the way from a Calyx program to a <code>wdb</code> file in the same way.
There is also a <code>wdb.save_temps</code> option, as with the <code>xclbin</code> stage.</p>
<p>You also need to provide a host C++ program via the <code>wdb.host</code> parameter, but I don't know much about that yet, so documentation about that will have to wait.
Similarly, I don't yet know what you're supposed to <em>do</em> with a WDB file; maybe we should figure out how to produce a VCD instead.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it Works</a></h3>
<p>The first step is to generate input files.
We need to generate:</p>
<ul>
<li>The RTL for the design itself, using the compile command-line flags <code>-b verilog --synthesis -p external</code>. We name this file <code>main.sv</code>.</li>
<li>A Verilog interface wrapper, using <code>XilinxInterfaceBackend</code>, via <code>-b xilinx</code>. We call this <code>toplevel.v</code>.</li>
<li>An XML document describing the interface, using <code>XilinxXmlBackend</code>, via <code>-b xilinx-xml</code>. This file gets named <code>kernel.xml</code>.</li>
</ul>
<p>The <code>fud</code> driver gathers these files together in a sandbox directory.
The next step is to run the Xilinx tools.</p>
<p>The rest of this section describes how this workflow works under the hood.
If you want to follow along by typing commands manually, you can start by invoking the setup scripts for <a href="https://www.xilinx.com/products/design-tools/vitis/vitis-platform.html">Vitis</a> and <a href="https://xilinx.github.io/XRT/">XRT</a>:</p>
<pre><code>source &lt;Vitis_install_path&gt;/Vitis/2020.1/settings64.sh
source /opt/xilinx/xrt/setup.sh
</code></pre>
<p>On some Ubuntu setups, you may need to update <code>LIBRARY_PATH</code>:</p>
<pre><code>export LIBRARY_PATH=/usr/lib/x86_64-linux-gnu
</code></pre>
<p>You can check that everything is working by typing <code>vitis -version</code> or <code>vivado -version</code>.</p>
<h4 id="background-xo-and-xclbin"><a class="header" href="#background-xo-and-xclbin">Background: <code>.xo</code> and <code>.xclbin</code></a></h4>
<p>In the Xilinx toolchain, compilation to an executable bitstream (or simulation blob) appears to requires two steps:
taking your Verilog sources and creating an <code>.xo</code> file, and then taking that and producing an <code>.xclbin</code> “executable” file.
The idea appears to be a kind of metaphor for a standard C compilation workflow in software-land: <code>.xo</code> is like a <code>.o</code> object file, and <code>.xclbin</code> contains actual executable code (bitstream or emulation equivalent), like a software executable binary.
Going from Verilog to <code>.xo</code> is like “compilation” and going from <code>.xo</code> to <code>.xclbin</code> is like “linking.”</p>
<p>However,  this analogy is kind of a lie.
Generating an <code>.xo</code> file actually does very little work:
it just packages up the Verilog source code and some auxiliary files.
An <code>.xo</code> is literally a zip file with that stuff packed up inside.
All the actual work happens during “linking,” i.e., going from <code>.xo</code> to <code>.xclbin</code> using the <code>v++</code> tool.
This situation is a poignant reminder of how impossible separate compilation is in the EDA world.
A proper analogy would involve separately compiling the Verilog into some kind of low-level representation, and then linking would properly smash together those separately-compiled objects.
Instead, in Xilinx-land, “compilation” is just simple bundling and “linking” does all the compilation in one monolithic step.
It’s kind of cute that the Xilinx toolchain is pretending the world is otherwise, but it’s also kind of sad.</p>
<p>Anyway, the only way to produce a <code>.xo</code> file from RTL code appears to be to use Vivado (i.e., the actual <code>vivado</code> program).
Nothing from the newer Vitis package currently appears capable of producing <code>.xo</code> files from Verilog (although <code>v++</code> can produce these files during HLS compilation, presumably by invoking Vivado).</p>
<p>The main components in an <code>.xo</code> file, aside from the Verilog source code itself, are two XML files:
<code>kernel.xml</code>, a short file describing the argument interfaces to the hardware design,
and <code>component.xml</code>, a much longer and more complicated <a href="https://en.wikipedia.org/wiki/IP-XACT">IP-XACT</a> file that also has to do with the interface to the RTL.
We currently generate <code>kernel.xml</code> ourselves (with the <code>xilinx-xml</code> backend described above) and then use Vivado, via a Tcl script, to generate the IP-XACT file.</p>
<p>In the future, we could consider trying to route around using Vivado by generating the IP-XACT file ourselves, using a tool such as <a href="https://github.com/sifive/duh">DUH</a>.</p>
<h4 id="our-workflow"><a class="header" href="#our-workflow">Our Workflow</a></h4>
<p>The first step is to produce an <code>.xo</code> file.
We also use <a href="https://github.com/cucapra/calyx/blob/master/fud/bitstream/gen_xo.tcl">a static Tcl script, <code>gen_xo.tcl</code>,</a> which is a simplified version of <a href="https://github.com/Xilinx/Vitis-Tutorials/blob/2021.1/Hardware_Acceleration/Feature_Tutorials/01-rtl_kernel_workflow/reference-files/scripts/package_kernel.tcl">a script from Xilinx's Vitis tutorials</a>.
The gist of this script is that it creates a Vivado project, adds the source files, twiddles some settings, and then uses the <a href="https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/package_xo-Command"><code>package_xo</code> command</a> to read stuff from this project as an &quot;IP directory&quot; and produce an <code>.xo</code> file.
The Vivado command line looks roughly like this:</p>
<pre><code>vivado -mode batch -source gen_xo.tcl -tclargs xclbin/kernel.xo
</code></pre>
<p>That output filename after <code>-tclargs</code>, unsurprisingly, gets passed to <a href="https://github.com/cucapra/calyx/blob/master/fud/bitstream/gen_xo.tcl"><code>gen_xo.tcl</code></a>.</p>
<p>Then, we take this <code>.xo</code> and turn it into an <a href="https://xilinx.github.io/XRT/2021.2/html/formats.html#xclbin"><code>.xclbin</code></a>.
This step uses the <code>v++</code> tool, with a command line that looks like this:</p>
<pre><code>v++ -g -t hw_emu --platform xilinx_u50_gen3x16_xdma_201920_3 --save-temps --profile.data all:all:all --profile.exec all:all:all -lo xclbin/kernel.xclbin xclbin/kernel.xo
</code></pre>
<p>Fortunately, the <code>v++</code> tool doesn't need any Tcl to drive it; all the action happens on the command line.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-stages"><a class="header" href="#external-stages">External Stages</a></h1>
<p><code>fud</code> supports using stages that aren't defined in its main source tree.
These are known as 'external stages' and the provide a mechanism
for projects using Calyx to take advantage of <code>fud</code>. You can register an
external stage with:</p>
<pre><code>fud register stage_name -p /path/to/stage.py
</code></pre>
<p>Once an external stage is registered, it behaves exactly like any other stage.</p>
<p>You can remove an external stage with:</p>
<pre><code>fud register stage_name --delete
</code></pre>
<p>The following defines a stage that transforms <a href="fud/../frontends/mrxl.html">MrXL</a> programs to Calyx
programs.</p>
<pre><code class="language-python">from fud.stages import Stage, SourceType
from fud.utils import shell


class MrXLStage(Stage):
    &quot;&quot;&quot;
    Stage that invokes the MrXL frontend.
    &quot;&quot;&quot;

    name = &quot;mrxl&quot;

    def __init__(self):
        &quot;&quot;&quot;
        Initialize this stage. Initializing a stage *does not* construct its
        computation graph.
        &quot;&quot;&quot;
        super().__init__(
            src_state=&quot;mrxl&quot;,
            target_state=&quot;futil&quot;,
            input_type=SourceType.Path,
            output_type=SourceType.Stream,
            description=&quot;Compiles MrXL to Calyx.&quot;,
        )

    @staticmethod
    def defaults():
        &quot;&quot;&quot;
        Specify defaults that should be added to fud's configuration file when
        this stage is registered.
        &quot;&quot;&quot;
        return {&quot;exec&quot;: &quot;mrxl&quot;}

    def _define_steps(self, input, builder, config):
        &quot;&quot;&quot;
        Define the steps that will execute in this stage. Each step represents
        a delayed computation that will occur when the stage is executed.
        &quot;&quot;&quot;

        # Commands at the top-level are evaluated when the computation is being
        # staged
        cmd = config[&quot;stages&quot;, self.name, &quot;exec&quot;]

        # Computations within a step are delayed from being executed until
        # the full execution pipeline is generated.
        @builder.step(description=cmd)
        def run_mrxl(mrxl_prog: SourceType.Path) -&gt; SourceType.Stream:
            return shell(f&quot;{cmd} {str(mrxl_prog)}&quot;)

        # Define a schedule using the steps.
        # A schedule *looks* like an imperative program but actually represents
        # a computation graph that is executed later on.
        return run_mrxl(input)


# Export the defined stages to fud
__STAGES__ = [MrXLStage]
</code></pre>
<p>External stages <em>must</em> define default values for configuration keys using the
<code>Stage.defaults()</code> static method and the name of the stage using the static
<code>name</code> field.</p>
<h2 id="stage-configuration"><a class="header" href="#stage-configuration">Stage Configuration</a></h2>
<p>Like normal stages, external stages can have persistent configuration
information saved using <code>fud config</code>.</p>
<p>To add persistent stage configuration, run:</p>
<pre><code>fud config stages.&lt;stage-name&gt;.&lt;key&gt; &lt;value&gt;
</code></pre>
<p>To dynamically override the value of a field during execution, use the <code>-s flag</code>:</p>
<pre><code>fud e -s &lt;stage-name&gt;.&lt;key&gt; &lt;value&gt; ...
</code></pre>
<p>The override order for stage configuration is:</p>
<ol>
<li>Dynamic values provided by <code>-s</code>.</li>
<li>Configuration value in the fud config.</li>
<li>Default value provided by <code>Stage.defaults()</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-paths"><a class="header" href="#multiple-paths">Multiple Paths</a></h1>
<p><code>fud</code> can define a stage graph that can have multiple paths between the source
and target.
For example, if you register the <a href="fud/./index.html#icarus-verilog">Icarus Verilog</a> simulator stage, then multiple
paths can be used to generate VCD files from Dahlia programs:</p>
<pre><code>% fud e --from dahlia --to vcd
[fud] ERROR: Multiple stage pipelines can transform dahlia to vcd:
dahlia → futil → verilog → vcd
dahlia → futil → icarus-verilog → vcd
Use the --through flag to select an intermediate stage
</code></pre>
<p><code>fud</code> says that both the <code>verilog</code> and <code>icarus-verilog</code> stages can be used to
generate the VCD file and you need to provide the <code>--through</code> flag to decide
which stage to select.</p>
<p>The following command will simulate the program using the <code>icarus-verilog</code>
stage:</p>
<pre><code>% fud e --from dahlia --to vcd --through icarus-verilog
</code></pre>
<p>In general, the <code>--through</code> flag can be repeated as many times as needed to
get a unique <code>fud</code> transformation pipeline.</p>
<h2 id="using-stage-priority"><a class="header" href="#using-stage-priority">Using Stage Priority</a></h2>
<p>If the common workflow uses the same stage every time, it can be annoying to
specify the stage name using the <code>--through</code> flag.
You can specify a priority field in the configuration of a stage to ensure
it <code>fud</code> automatically selects it when multiple paths exists.</p>
<p>For example, to always select the <code>verilog</code> stage, add the priority <code>1</code> to the
stage:</p>
<pre><code>fud c stages.verilog.priority 1
</code></pre>
<p>Now, the command <code>fud e --from dahlia --to vcd</code> is no longer ambiguous; <code>fud</code>
will always choose the <code>verilog</code> stage to transform programs from Dahlia
sources to VCD.</p>
<p>In case multiple paths have the same cost, <code>fud</code> will again require the
<code>--through</code> flag to disambiguate paths.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circt"><a class="header" href="#circt">CIRCT</a></h1>
<p>An ongoing effort is under way to establish Calyx as a dialect in the LLVM umbrella project <a href="https://circt.llvm.org/">CIRCT</a>.
There is documentation about the Calyx dialect <a href="https://circt.llvm.org/docs/Dialects/Calyx/">on the MLIR site</a>. While semantically
equivalent, they are syntactically different.  Because the Calyx dialect is still under progress and
does not include all the optimizations that the native Rust compiler supports, we have crafted an emitter
from the Calyx dialect (MLIR) to the native compiler representation (used by the Rust compiler). This means
you can lower from your favorite frontend in MLIR to the Calyx dialect, and continue all the way to
SystemVerilog (with spunky optimizations) using the native compiler.</p>
<p>The native compiler also supports round-tripping back into the MLIR representation. We'll assume you've
already built the Rust compiler and installed <code>fud</code>. Here are the steps below to round-trip:</p>
<h2 id="mlir-to-native-representation"><a class="header" href="#mlir-to-native-representation">MLIR to Native Representation</a></h2>
<ol>
<li>
<p>Set up the CIRCT project with <a href="https://github.com/llvm/circt#setting-this-up">these instructions</a>.</p>
</li>
<li>
<p>There should be a <code>circt-translate</code> binary in <code>&lt;root-directory&gt;/build/bin</code>. To emit the native compiler
representation, use the command:</p>
</li>
</ol>
<pre><code>path/to/circt-translate --export-calyx /path/to/file
</code></pre>
<p>For example, you can use the expected output of the test <code>tests/backend/mlir/simple.expect</code>:</p>
<pre><code>calyx.program &quot;main&quot; {

calyx.component @main(%go: i1 {go=1}, %clk: i1 {clk=1}, %reset: i1 {reset=1}) -&gt; (%out: i1, %done: i1 {done=1}) {
  %r1.in, %r1.write_en, %r1.clk, %r1.reset, %r1.out, %r1.done = calyx.register @r1 : i1, i1, i1, i1, i1, i1
  %_1_1.out = hw.constant 1 : i1
  calyx.wires {
    calyx.group @Group1 {
      calyx.assign %r1.in = %_1_1.out : i1
      calyx.assign %r1.write_en = %_1_1.out : i1
      calyx.group_done %r1.done : i1
    }
  }

  calyx.control {
    calyx.seq {
      calyx.enable @Group1
    }
  }
}

}
</code></pre>
<p>Using the command:</p>
<pre><code class="language-bash"># Don't worry too much about the file alias; this is used for testing purposes.
path/to/circt-translate --export-calyx tests/backend/mlir/simple.expect
</code></pre>
<p>This should output:</p>
<pre><code>// -p well-formed -b mlir
import &quot;primitives/core.futil&quot;;
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -&gt; (out: 1, @done done: 1) {
  cells {
    r1 = std_reg(1);
  }
  wires {
    group Group1 {
      r1.in = 1'd1;
      r1.write_en = 1'd1;
      Group1[done] = r1.done;
    }
  }
  control {
    seq { Group1; }
  }
}
</code></pre>
<h2 id="native-representation-to-mlir"><a class="header" href="#native-representation-to-mlir">Native Representation to MLIR</a></h2>
<p>To round-trip back to the Calyx dialect, we can use <code>fud</code>:</p>
<pre><code class="language-sh">fud exec path/to/file --to mlir
</code></pre>
<p>For example,</p>
<pre><code class="language-sh">fud exec tests/backend/mlir/simple.futil --to mlir
</code></pre>
<p>This should emit the Calyx dialect once again.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-calyx-interpreter"><a class="header" href="#the-calyx-interpreter">The Calyx Interpreter</a></h1>
<p>The experimental Calyx interpreter resides in the <code>interp/</code> directory of the
repository.
The interpreter supports all Calyx programs---from high-level programs that
make heavy use of control operators, to fully lowered Calyx programs.
(RTL simulation, in contrast, only supports execution of fully lowered programs.)</p>
<p>There are two ways to use the interpreter: you can directly invoke it, or you can use <a href="fud/index.html">fud</a>.</p>
<h2 id="basic-use"><a class="header" href="#basic-use">Basic Use</a></h2>
<p>To run an example program, try:</p>
<pre><code>cd interp &amp;&amp; cargo run tests/control/if.futil
</code></pre>
<p>You can see the available command-line options by typing <code>cargo run -- --help</code>.</p>
<h2 id="interpreting-via-fud"><a class="header" href="#interpreting-via-fud">Interpreting via fud</a></h2>
<p>The interpreter is available as a stage in <a href="fud/index.html">fud</a>, which lets you provide standard JSON data files as input and easily execute passes on the input Calyx program before interpretation.</p>
<p>You'll want to build the interpreter first:</p>
<pre><code>cd interp &amp;&amp; cargo build
</code></pre>
<p>Here's how to run a Calyx program:</p>
<pre><code>fud e --to interpreter-out interp/tests/control/if.futil
</code></pre>
<p>To provide input data, set the <code>verilog.data</code> variable, like so:</p>
<pre><code>fud e --to interpreter-out \
    -s verilog.data tests/correctness/while.futil.data \
    tests/correctness/while.futil
</code></pre>
<p>By default, fud will not transform the Calyx code before feeding it to the interpreter.
To run passes before the interpreter, use the <code>futil.flags</code> variable in conjunction with the <code>-p</code> flag.
For example, to fully lower the Calyx program before interpreting it:</p>
<pre><code>fud e --to interpreter-out \
    -s futil.flags '-p all' \
    interp/tests/control/if.futil
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-calyx-compiler"><a class="header" href="#the-calyx-compiler">The Calyx Compiler</a></h1>
<p>The source code documentation for the compiler can be <a href="https://docs.calyxir.org/source/calyx/">found here</a>.</p>
<p>The Calyx compiler has several command line to control the execution of various
passes and backends.</p>
<h2 id="specifying-primitives-library"><a class="header" href="#specifying-primitives-library">Specifying Primitives Library</a></h2>
<p>The compiler implementation uses a standard library of components to compile
programs.</p>
<p>The only standard library for the compiler is located in:</p>
<pre><code>&lt;path to Calyx repository&gt;/primitives
</code></pre>
<p>Specify the location of the library using the <code>-l</code> flag:</p>
<pre><code>cargo run -- -l ./primitives
</code></pre>
<h2 id="primitive-libraries-format"><a class="header" href="#primitive-libraries-format">Primitive Libraries Format</a></h2>
<p>The primitive libraries consist of a <code>.futil</code> file paired with a <code>.sv</code> file. The
<code>.futil</code> file defines a series of Calyx shim bindings in <code>extern</code> blocks which
match up with SystemVerilog definitions of those primitives. These libraries may
also expose components written in Calyx, usually defined using primitives
exposed by the file.</p>
<p>No Calyx program can work without the primitives defined in the <a href="libraries/core.html">Core Library</a>.</p>
<h2 id="controlling-passes"><a class="header" href="#controlling-passes">Controlling Passes</a></h2>
<p>The compiler is organized as a sequence of passes that are run when the compiler
executes.</p>
<p>To get a complete list of all passes, run the following from the repository
root:</p>
<pre><code>cargo run -- --list-passes
</code></pre>
<p>This generates results of the form:</p>
<pre><code>Passes:
- collapse-control
- compile-control
...

Aliases:
- all: well-formed, papercut, remove-external-memories, ...
...
</code></pre>
<p>The first section list all the passes implemented in the compiler.
The second section lists <em>aliases</em> for combination of passes that are commonly
run together.
For example, the alias <code>all</code> is an ordered sequence of default passes executed
when the compiler is run from the command-line.</p>
<p>The command-line provides two options to control the execution of passes:</p>
<ul>
<li><code>-p, --pass</code>: Execute this pass or alias. Overrides default alias.</li>
<li><code>-d, --disable-pass</code>: Disable this pass or alias. Takes priority over <code>-p</code>.</li>
</ul>
<p>For example, we can run the following to disable the <code>static-timing</code> pass from
the default execution alias <code>all</code>:</p>
<pre><code class="language-bash">cargo run -- examples/futil/simple.futil -p all -d static-timing
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-library"><a class="header" href="#core-library">Core Library</a></h1>
<p>This library defines a standard set of components used in most Calyx programs
such as registers and basic bitwise operations.</p>
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<ul>
<li><a href="libraries/core.html#numerical-operators">Numerical Operators</a></li>
<li><a href="libraries/core.html#logical-operators">Logical Operators</a></li>
<li><a href="libraries/core.html#comparison-operators">Comparison Operators</a></li>
<li><a href="libraries/core.html#memories">Memories</a></li>
</ul>
<hr />
<h2 id="numerical-operators"><a class="header" href="#numerical-operators">Numerical Operators</a></h2>
<h3 id="std_regwidth"><a class="header" href="#std_regwidth"><code>std_reg&lt;WIDTH&gt;</code></a></h3>
<p>A <code>WIDTH</code>-wide register.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>in: WIDTH</code> - An input value to the register <code>WIDTH</code>-bits.</li>
<li><code>write_en: 1</code> - The one bit write enabled signal. Indicates that the register
should store the value on the in wire.</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - The value contained in the register.</li>
<li><code>done: 1</code> - The register's done signal. Set high for one cycle after writing a
new value.</li>
</ul>
<hr />
<h3 id="std_constwidthval"><a class="header" href="#std_constwidthval"><code>std_const&lt;WIDTH,VAL&gt;</code></a></h3>
<p>A constant WIDTH-bit value with value VAL.</p>
<p><strong>Inputs:</strong> None</p>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - The value of the constant (i.e. <code>VAL</code>)</li>
</ul>
<hr />
<h3 id="std_lshwidth"><a class="header" href="#std_lshwidth"><code>std_lsh&lt;WIDTH&gt;</code></a></h3>
<p>A left bit shift. Performs <code>LEFT &lt;&lt; RIGHT</code>. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit value to be shifted</li>
<li><code>right: WIDTH</code> - A WIDTH-bit value representing the shift amount</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - A WIDTH-bit value equivalent to <code>LEFT &lt;&lt; RIGHT</code></li>
</ul>
<hr />
<h3 id="std_rshwidth"><a class="header" href="#std_rshwidth"><code>std_rsh&lt;WIDTH&gt;</code></a></h3>
<p>A right bit shift. Performs <code>LEFT &gt;&gt; RIGHT</code>. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit value to be shifted</li>
<li><code>right: WIDTH</code> - A WIDTH-bit value representing the shift amount</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - A WIDTH-bit value equivalent to <code>LEFT &gt;&gt; RIGHT</code></li>
</ul>
<hr />
<h3 id="std_addwidth"><a class="header" href="#std_addwidth"><code>std_add&lt;WIDTH&gt;</code></a></h3>
<p>Bitwise addition without a carry flag. Performs <code>LEFT + RIGHT</code>. This component
is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit value</li>
<li><code>right: WIDTH</code> - A WIDTH-bit value</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - A WIDTH-bit value equivalent to <code>LEFT + RIGHT</code></li>
</ul>
<hr />
<h3 id="std_subwidth"><a class="header" href="#std_subwidth"><code>std_sub&lt;WIDTH&gt;</code></a></h3>
<p>Bitwise subtraction. Performs <code>LEFT - RIGHT</code>. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit value</li>
<li><code>right: WIDTH</code> - A WIDTH-bit value</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - A WIDTH-bit value equivalent to <code>LEFT - RIGHT</code></li>
</ul>
<hr />
<h3 id="std_slicein_width-out_width"><a class="header" href="#std_slicein_width-out_width"><code>std_slice&lt;IN_WIDTH, OUT_WIDTH&gt;</code></a></h3>
<p>Slice out the lower OUT_WIDTH bits of an IN_WIDTH-bit value. Computes
<code>in[out_width - 1 : 0]</code>. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>in: IN_WIDTH</code> - An IN_WIDTH-bit value</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: OUT_WIDTH</code> - The lower OUT_WIDTH bits of <code>in</code></li>
</ul>
<hr />
<h3 id="std_padin_width-out_width"><a class="header" href="#std_padin_width-out_width"><code>std_pad&lt;IN_WIDTH, OUT_WIDTH&gt;</code></a></h3>
<p>Given an IN_WIDTH-bit input, zero pad from the left to an output of
OUT_WIDTH-bits. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>in: IN_WIDTH</code> - An IN_WIDTH-bit value to be padded</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: OUT_WIDTH</code> - The padded value</li>
</ul>
<hr />
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<h3 id="std_notwidth"><a class="header" href="#std_notwidth"><code>std_not&lt;WIDTH&gt;</code></a></h3>
<p>Bitwise NOT. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>in: WIDTH</code> - A WIDTH-bit input.</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - The bitwise NOT of the input (<code>~in</code>)</li>
</ul>
<hr />
<h3 id="std_andwidth"><a class="header" href="#std_andwidth"><code>std_and&lt;WIDTH&gt;</code></a></h3>
<p>Bitwise AND. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - The bitwise AND of the arguments (<code>left &amp; right</code>)</li>
</ul>
<hr />
<h3 id="std_orwidth"><a class="header" href="#std_orwidth"><code>std_or&lt;WIDTH&gt;</code></a></h3>
<p>Bitwise OR. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - The bitwise OR of the arguments (<code>left | right</code>)</li>
</ul>
<hr />
<h3 id="std_xorwidth"><a class="header" href="#std_xorwidth"><code>std_xor&lt;WIDTH&gt;</code></a></h3>
<p>Bitwise XOR. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: WIDTH</code> - The bitwise XOR of the arguments (<code>left ^ right</code>)</li>
</ul>
<hr />
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<h3 id="std_gtwidth"><a class="header" href="#std_gtwidth"><code>std_gt&lt;WIDTH&gt;</code></a></h3>
<p>Greater than. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: 1</code> - A single bit output. 1 if <code>left &gt; right</code> else 0.</li>
</ul>
<hr />
<h3 id="std_ltwidth"><a class="header" href="#std_ltwidth"><code>std_lt&lt;WIDTH&gt;</code></a></h3>
<p>Less than. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: 1</code> - A single bit output. 1 if <code>left &lt; right</code> else 0.</li>
</ul>
<hr />
<h3 id="std_eqwidth"><a class="header" href="#std_eqwidth"><code>std_eq&lt;WIDTH&gt;</code></a></h3>
<p>Equality comparison. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: 1</code> - A single bit output. 1 if <code>left = right</code> else 0.</li>
</ul>
<hr />
<h3 id="std_neqwidth"><a class="header" href="#std_neqwidth"><code>std_neq&lt;WIDTH&gt;</code></a></h3>
<p>Not equal. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: 1</code> - A single bit output. 1 if <code>left != right</code> else 0.</li>
</ul>
<hr />
<h3 id="std_gewidth"><a class="header" href="#std_gewidth"><code>std_ge&lt;WIDTH&gt;</code></a></h3>
<p>Greater than or equal. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: 1</code> - A single bit output. 1 if <code>left &gt;= right</code> else 0.</li>
</ul>
<hr />
<h3 id="std_lewidth"><a class="header" href="#std_lewidth"><code>std_le&lt;WIDTH&gt;</code></a></h3>
<p>Less than or equal. This component is combinational.</p>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>left: WIDTH</code> - A WIDTH-bit argument</li>
<li><code>right: WIDTH</code> - A WIDTH-bit argument</li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>out: 1</code> - A single bit output. 1 if <code>left &lt;= right</code> else 0.</li>
</ul>
<hr />
<h2 id="memories"><a class="header" href="#memories">Memories</a></h2>
<h3 id="std_mem_d1"><a class="header" href="#std_mem_d1"><code>std_mem_d1</code></a></h3>
<p>A one-dimensional memory.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>WIDTH</code> - Size of an individual memory slot.</li>
<li><code>SIZE</code> - Number of slots in the memory.</li>
<li><code>IDX_SIZE</code> - The width of the index given to the memory.</li>
</ul>
<p><strong>Inputs:</strong></p>
<ul>
<li>`addr0: IDX_SIZE - The index to be accessed or updated</li>
<li><code>write_data: WIDTH</code> - Data to be written to the selected memory slot</li>
<li><code>write_en: 1</code> - One bit write enabled signal, causes the memory to write <code>write_data</code> to the slot indexed by <code>addr0</code></li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>read_data: WIDTH</code> - The value stored at <code>addr0</code>. This value is combinational with respect to <code>addr0</code>.</li>
<li><code>done: 1</code>: The done signal for the memory. This signal goes high for one cycle after finishing a write to the memory.</li>
</ul>
<hr />
<h3 id="std_mem_d2"><a class="header" href="#std_mem_d2"><code>std_mem_d2</code></a></h3>
<p>A two-dimensional memory.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>WIDTH</code> - Size of an individual memory slot.</li>
<li><code>D0_SIZE</code> - Number of memory slots for the first index.</li>
<li><code>D1_SIZE</code> - Number of memory slots for the second index.</li>
<li><code>D0_IDX_SIZE</code> - The width of the first index.</li>
<li><code>D1_IDX_SIZE</code> - The width of the second index.</li>
</ul>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>addr0: D0_IDX_SIZE</code> - The first index into the memory</li>
<li><code>addr1: D1_IDX_SIZE</code> - The second index into the memory</li>
<li><code>write_data: WIDTH</code> - Data to be written to the selected memory slot</li>
<li><code>write_en: 1</code> - One bit write enabled signal, causes the memory to write <code>write_data</code> to the slot indexed by <code>addr0</code> and <code>addr1</code></li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>read_data: WIDTH</code> - The value stored at <code>mem[addr0][addr1]</code>. This value is combinational with respect to <code>addr0</code> and <code>addr1</code>.</li>
<li><code>done: 1</code>: The done signal for the memory. This signal goes high for one cycle after finishing a write to the memory.</li>
</ul>
<hr />
<h3 id="std_mem_d3"><a class="header" href="#std_mem_d3"><code>std_mem_d3</code></a></h3>
<p>A three-dimensional memory.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>WIDTH</code> - Size of an individual memory slot.</li>
<li><code>D0_SIZE</code> - Number of memory slots for the first index.</li>
<li><code>D1_SIZE</code> - Number of memory slots for the second index.</li>
<li><code>D2_SIZE</code> - Number of memory slots for the third index.</li>
<li><code>D0_IDX_SIZE</code> - The width of the first index.</li>
<li><code>D1_IDX_SIZE</code> - The width of the second index.</li>
<li><code>D2_IDX_SIZE</code> - The width of the third index.</li>
</ul>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>addr0: D0_IDX_SIZE</code> - The first index into the memory</li>
<li><code>addr1: D1_IDX_SIZE</code> - The second index into the memory</li>
<li><code>addr2: D2_IDX_SIZE</code> - The third index into the memory</li>
<li><code>write_data: WIDTH</code> - Data to be written to the selected memory slot</li>
<li><code>write_en: 1</code> - One bit write enabled signal, causes the memory to write <code>write_data</code> to the slot indexed by <code>addr0</code>, <code>addr1</code>, and <code>addr2</code></li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>read_data: WIDTH</code> - The value stored at <code>mem[addr0][addr1][addr2]</code>. This value is combinational with respect to <code>addr0</code>, <code>addr1</code>, and <code>addr2</code>.</li>
<li><code>done: 1</code>: The done signal for the memory. This signal goes high for one cycle after finishing a write to the memory.</li>
</ul>
<hr />
<h3 id="std_mem_d4"><a class="header" href="#std_mem_d4"><code>std_mem_d4</code></a></h3>
<p>A four-dimensional memory.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>WIDTH</code> - Size of an individual memory slot.</li>
<li><code>D0_SIZE</code> - Number of memory slots for the first index.</li>
<li><code>D1_SIZE</code> - Number of memory slots for the second index.</li>
<li><code>D2_SIZE</code> - Number of memory slots for the third index.</li>
<li><code>D3_SIZE</code> - Number of memory slots for the fourth index.</li>
<li><code>D0_IDX_SIZE</code> - The width of the first index.</li>
<li><code>D1_IDX_SIZE</code> - The width of the second index.</li>
<li><code>D2_IDX_SIZE</code> - The width of the third index.</li>
<li><code>D3_IDX_SIZE</code> - The width of the fourth index.</li>
</ul>
<p><strong>Inputs:</strong></p>
<ul>
<li><code>addr0: D0_IDX_SIZE</code> - The first index into the memory</li>
<li><code>addr1: D1_IDX_SIZE</code> - The second index into the memory</li>
<li><code>addr2: D2_IDX_SIZE</code> - The third index into the memory</li>
<li><code>addr3: D3_IDX_SIZE</code> - The fourth index into the memory</li>
<li><code>write_data: WIDTH</code> - Data to be written to the selected memory slot</li>
<li><code>write_en: 1</code> - One bit write enabled signal, causes the memory to write <code>write_data</code> to the slot indexed by <code>addr0</code>, <code>addr1</code>, <code>addr2</code>, and <code>addr3</code></li>
</ul>
<p><strong>Outputs:</strong></p>
<ul>
<li><code>read_data: WIDTH</code> - The value stored at <code>mem[addr0][addr1][addr2][addr3]</code>. This value is combinational with respect to <code>addr0</code>, <code>addr1</code>, <code>addr2</code>, and <code>addr3</code>.</li>
<li><code>done: 1</code>: The done signal for the memory. This signal goes high for one cycle after finishing a write to the memory.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-calyx-library"><a class="header" href="#the-calyx-library">The calyx Library</a></h1>
<p>The implementation of the compiler separates the frontend from the internal data structures.
This allows developers to use the compiler as a library.
The <code>calyx</code> library exports all the data structures used by the compiler can be used to design new
tools that make use of Calyx.</p>
<p>See the <a href="https://docs.calyxir.org/source/calyx/">library documentation</a> for an example of how to use the <code>calyx</code> library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dataflow-optimizations"><a class="header" href="#dataflow-optimizations">Dataflow Optimizations</a></h1>
<p>In general, dataflow analysis uses the control and data flow of a program to compute
various properties (liveness, reaching definitions, ...) at each point in a program.</p>
<p>For Calyx, dataflow analyses use the explicit control program and knowledge about
the dataflow of each group to compute properties about each group.</p>
<h2 id="basic-blocks-vs-groups"><a class="header" href="#basic-blocks-vs-groups">Basic blocks vs. Groups</a></h2>
<p>Normally, dataflow analyses compute a property at each basic block of a control
flow graph (CFG). Calyx doesn't have a notion of basic blocks, and so Calyx computes
a property at each group in a program.</p>
<p>Because Calyx separates the control flow of a program from the specification of
groups, it's possible for a group to appear multiple times in the control program.
For this reason we compute a property at each group <em>enable</em> rather than each group
<em>definition</em>. The property at each group <em>definition</em> can easily be computed
as the meet over all group enables.</p>
<h2 id="dataflow-on-an-ast"><a class="header" href="#dataflow-on-an-ast">Dataflow on an AST</a></h2>
<p>Dataflow analyses are typically performed by finding the fixed point
of a set of equations defined at each node of a control flow graph (CFG)
using the <a href="https://en.wikipedia.org/wiki/Data-flow_analysis#An_iterative_algorithm">worklist algorithm</a>.</p>
<p>Because our control AST is little more than just the edges of a <a href="https://en.wikipedia.org/wiki/Control-flow_graph#Reducibility">reducible cfg</a>,
we don't bother to build an explicit CFG and instead perform the
dataflow analysis directly on the AST using Calyx's visitor infrastructure.</p>
<h3 id="abstract-algorithm"><a class="header" href="#abstract-algorithm">Abstract Algorithm</a></h3>
<p>We model each control statement <code>s</code> as a function, <code>f: p -&gt; p</code> where <code>p</code> is
the type of the property. Control statements that have children define how information
flows between its children.</p>
<h4 id="enable"><a class="header" href="#enable">Enable</a></h4>
<p><code>f</code> for <code>enable A</code> is similar to the transfer function in standard dataflow analysis. It
uses information from the definition of group <code>A</code> to modify the input in some way. For example,
if <code>p</code> is the set of live variables, the enable <code>f</code> is defined as:</p>
<pre><code>f(enable A, inputs) = (inputs - kill(A)) | gen(A)
</code></pre>
<h4 id="seq-1"><a class="header" href="#seq-1">Seq</a></h4>
<p><code>seq</code> defines sequential control flow edges between its children.
It is implemented by threading its input through all of its children to produce an output.</p>
<pre><code>f(seq { A; B; C; ...; Z; }, inputs) =
     f(A, inputs)
  |&gt; f(B, _)
  |&gt; f(C, _)
  |&gt; ...
  |&gt; f(Z, _)
</code></pre>
<p>To implement a backwards dataflow analysis, all you need to do is reverse the
order that <code>seq</code> pipes inputs to its children:</p>
<pre><code>// reverse
f(seq { A; B; C; ...; Z; }, inputs) =
     f(Z, inputs)
  |&gt; ...
  |&gt; f(C, _)
  |&gt; f(B, _)
  |&gt; f(A, _)
</code></pre>
<h4 id="if-1"><a class="header" href="#if-1">If</a></h4>
<p><code>if</code> passes its inputs to its condition group and then feeds the result of this
to both of its children. The output is the union of the outputs of both of its
children. This is standard.</p>
<pre><code>f(if some.port with G { True; } else { False; }, inputs) =
  f(True, f(G, inputs)) | f(False, f(G, inputs))
</code></pre>
<h4 id="while-1"><a class="header" href="#while-1">While</a></h4>
<p><code>while</code> statements are interesting because the outputs of the body may affect the
input to the body. For this reason, we need to find a fixed point:</p>
<pre><code>f(while some.port with G { body; }, inputs) =
  P = inputs;
  loop until P stops changing {
    P = f(body, f(G, inputs))
  }
</code></pre>
<h4 id="par-1"><a class="header" href="#par-1">Par</a></h4>
<p>Par is the only statement that differs substantially from traditional dataflow because
control flow graphs don't support nodes running in parallel. In other words, there is only
ever one thing executing. However, <code>par</code> changes this and allows multiple things to
execute at the same time. Consider the following example where we are computing
the liveness of <code>x</code> to see why this is weird:</p>
<pre><code>F; // wr x
...
par {
  A; // wr x
  B;
}
G; // rd x
</code></pre>
<p>Is <code>x</code> alive between <code>X</code> and the beginning of <code>par</code>? The answer is no because we know
that <em>both</em> <code>A</code> and <code>B</code> will run. Therefore the write to <code>x</code> in <code>F</code> can not be seen by any
group.</p>
<p>At first glance this doesn't seem like a problem. Great, we say, we can just take
the union of the outputs of the children of <code>par</code> and call it a day.</p>
<img src="optimizations/par1.png" width="35%"/>
<p>This is wrong because <code>B</code> doesn't kill <code>x</code> and so <code>x</code> is alive coming into <code>B</code>.
The union preserves this information and results in <code>x</code> being alive above <code>par</code>.</p>
<p>Taking the set intersection is not quite right here either. Consider adding another group
<code>C</code> that reads from <code>x</code>.</p>
<img src="optimizations/par2.png" width="40%"/>
<p>We have no information about how this read is ordered with the write
to <code>x</code> in <code>A</code> so we have to assume that <code>x</code> is alive above <code>par</code>. If we take the intersection
here:</p>
<pre><code>  live(A) &amp; live(B) &amp; live(C)
= {} &amp; {x} &amp; {x}
= {}
</code></pre>
<p>We get the wrong answer. More generally, we can see that union clobbers
any writes and intersection clobbers any reads that happen in the par.</p>
<p>The solution to this problem is solved by passing the <code>gen</code> and <code>kill</code> sets along
with the <code>live</code> sets. Then <code>par</code> can set its output to be </p>
<pre><code>(union(live(children)) - union(kill(children))) | union(gen(children))
</code></pre>
<p>The final tricky bit is thinking about how information flows between siblings in a <code>par</code> statement.
Consider again the picture above with three nodes: <code>A</code>, <code>B</code>, and <code>C</code>. Should <code>x</code> be live
at <code>B</code>? For liveness it turns out to be yes, but bare with me for a second for a thought experiment
and consider the case where we have the guarantee that statements running in parallel can not interact 
with each other. This lets us reorder statements in some cases.
Then there seems to be an information trade-off for how to define the liveness of <code>x</code> at <code>B</code>:</p>
<ul>
<li>You could say that <code>x</code> is dead at <code>B</code> because it doesn't see any previous writes to <code>x</code>
and doesn't read from <code>x</code>. This implies that you could potentially replace writes to other
registers with <code>x</code>. However, this by itself would cause <code>x</code> to be written to twice in parallel.
You would have to reorder <code>B</code> to run before <code>A</code>. The takeaway here is that calling <code>x</code> dead
at <code>B</code> gives the register reuse pass more information to work with. To compute
this information <code>B</code> needs the <code>gens</code> and <code>kills</code> from all of its siblings (for the same reason that <code>par</code>)
needed it. This is not particularly hard to implement, but it's worthy of noting.</li>
<li>If you say that <code>x</code> is live at <code>B</code>, then you can never rewrite <code>B</code> to use <code>x</code> instead
of some other register, but you also don't have to worry about reordering statements in a <code>par</code>.</li>
</ul>
<p>Leaving thought experiment land, in our case we can never reorder statements in a <code>par</code> because
siblings may interact with each other in arbitrary ways. For this reason, we must say that <code>x</code>
is live at <code>B</code>. However, it's not immediately clear to me that this will be true of all dataflow
analyses. That's why I set this thought experiment down in writing.</p>
<h3 id="equivalence-to-worklist-algorithm"><a class="header" href="#equivalence-to-worklist-algorithm">Equivalence to worklist algorithm</a></h3>
<p>In the normal worklist algorithm, we add a statement back to the worklist when
its predecessor has changed.</p>
<p>The intuition for why this algorithm is equivalent to worklist algorithm is
that because the only entry into the children for each parent control statement
is the parent control statement itself. The only way that a child statement would
need to be recomputed is if the inputs to the parent need to be recomputed. Anything
above the parent in the tree will take care of this re-computation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Calyx programs can provide wrong answers for two reasons:</p>
<ol>
<li>The program implements the wrong algorithm, i.e., it has a logical bug.</li>
<li>The Calyx compiler incorrectly compiles the program, i.e., there is a compilation bug.</li>
</ol>
<p>First make sure that the program generates the correct values with the <a href="debug/../interpreter.html">Calyx
Interpreter</a>. If it produces the wrong values, your Calyx implementation of the
algorithm is incorrect. You can use the <a href="debug/./cider.html">Calyx Debugger</a> to debug these problems.</p>
<p>If the interpreter produces the right values, try a different Verilog backed. We support both
<a href="debug/../fud/index.html#verilator">Verilator</a> and <a href="debug/../fud/index.html#icarus-verilog">Icarus Verilog</a>. If
both produce the wrong answer <em>and</em> the interpreter produces the right answer then you likely have
a compilation bug on your hands. Use the <a href="debug/./debug.html">debugging tips</a> to narrow down the pass that causes
the error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-calyx-interactive-debugger"><a class="header" href="#the-calyx-interactive-debugger">The Calyx Interactive Debugger</a></h1>
<p>The Calyx Interactive Debugger is a prototype debugging tool built on top of the
[Calyx Interpreter][interp] which exposes a <a href="https://sourceware.org/gdb/">gdb</a>-like interface for
debugging Calyx programs.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>If you are using <a href="debug//fud/index.html"><code>fud</code></a> getting started with the debugger is easy.
Assuming you are trying to debug a program called <code>my_program.futil</code> with data
file <code>my_program.futil.data</code>, invoke the debugger with the following command:</p>
<pre><code>fud e --to debugger -q my_program.futil -s verilog.data my_program.futil.data
</code></pre>
<p>This will open the target program in the interactive debugger. Note that <code>fud</code>
uses <strong>the quiet flag</strong>, <code>-q</code>, here. This prevents the printing from the <code>fud</code> tool
from conflicting the debugger as both tools interact with standard out.</p>
<h2 id="advancing-program-execution"><a class="header" href="#advancing-program-execution">Advancing Program execution</a></h2>
<h3 id="step"><a class="header" href="#step"><code>step</code></a></h3>
<p>The simplest way to advance the program is via the <code>step</code> command which causes
time to advance by a clock tick. It also has a shortcode: <code>s</code>.</p>
<pre><code> &gt; step
 &gt; s
</code></pre>
<p>The above snippet advances the program by two steps.</p>
<h3 id="step-over"><a class="header" href="#step-over"><code>step-over</code></a></h3>
<p>Another way to advance the program is via the <code>step-over</code> command. Unlike the
<code>step</code> command, this command requires a second argument which is the name of the
group to advance over. The <code>step-over</code> command then advances the program until
the given group is no longer running.</p>
<p>If you want to use the command to advance the program past a group <code>group_1</code>, do
the following:</p>
<pre><code> &gt; step-over group_1
</code></pre>
<p>Note that the <code>step-over</code> command will do nothing if the given group is not
running.</p>
<pre><code> &gt; step-over other_group
 Group is not running
 &gt;
</code></pre>
<h3 id="continue"><a class="header" href="#continue"><code>continue</code></a></h3>
<p>Finally, the continue command will run the program until either a breakpoint is
hit or the program terminates. This command is used in conjunction with
breakpoints and watchpoints to provide more targeted inspection. It may also be
accessed with the shortcode <code>c</code>.</p>
<pre><code> &gt; continue
Main component has finished executing. Debugger is now in inspection mode.
</code></pre>
<h2 id="breakpoints"><a class="header" href="#breakpoints">Breakpoints</a></h2>
<p>CIDR supports breakpoints on group definitions. This helps focus attention on
suspect portions of the code.</p>
<h3 id="setting-a-breakpoint"><a class="header" href="#setting-a-breakpoint">Setting a breakpoint</a></h3>
<p>Breakpoints may be set on the main component by simple specifying the group of
interest.</p>
<pre><code> &gt; break group_1
</code></pre>
<p>This is identical to</p>
<pre><code> &gt; break main::group_1
</code></pre>
<p>For sub-components, the name of the sub-component must be included with the
double colon separating the group name. To break on the <code>do_mul</code> group inside
the <code>pow</code> sub-component:</p>
<pre><code> &gt; break pow::do_mul
</code></pre>
<h3 id="managing-breakpoints"><a class="header" href="#managing-breakpoints">Managing breakpoints</a></h3>
<p>To see a list of breakpoints:</p>
<pre><code> &gt; info break
</code></pre>
<p>or</p>
<pre><code> &gt; ib
</code></pre>
<p>This produces output like this:</p>
<pre><code> &gt; ib
     Current breakpoints:
    1.  main::group_1  enabled
    2.  pow::do_mul enabled
</code></pre>
<p>All breakpoints have a number associated with them and they may be managed with
this number or the group name.</p>
<p>To enable or disable a breakpoint:</p>
<pre><code> &gt; disable group_1 2
 &gt; enable 1 pow::do_mul
</code></pre>
<p>Note that this is equivalent to:</p>
<pre><code> &gt; disable group_1
 &gt; disable 2
 &gt; enable 1
 &gt; enable pow::do_mul
</code></pre>
<p>To delete a breakpoint:</p>
<pre><code> &gt; delete 1
 &gt; del pow::do_mul
</code></pre>
<p>Deleted breakpoints will be entirely removed while disabled breakpoints will
remain until they are either enabled again or subsequently deleted. Disabled
breakpoints will not cause program execution to halt when <code>continue</code>-ing.</p>
<h2 id="inspecting-state"><a class="header" href="#inspecting-state">Inspecting State</a></h2>
<h3 id="display"><a class="header" href="#display"><code>display</code></a></h3>
<p>The display command dumps the full state of the main component without
formatting. Use the <code>print</code> and <code>print-state</code> commands for targeted inspection
with formatting.</p>
<h3 id="formatting-codes"><a class="header" href="#formatting-codes">Formatting codes</a></h3>
<p>CIDR supports several different formatting codes which do the hard work of
interpreting the data in human readable ways.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>code</th><th>description</th></tr></thead><tbody>
<tr><td>binary</td><td></td><td>The default, a bit vector with the msb on the left</td></tr>
<tr><td>unsigned</td><td>\u</td><td>Unsigned bit-num formatting</td></tr>
<tr><td>signed</td><td>\s</td><td>Two's Complement formatting</td></tr>
<tr><td>unsigned fixedpoint</td><td>\u.N</td><td>For N &gt;=1. Unsigned Fixed-point with N fractional bits. The remaining bits are for the integral component.</td></tr>
<tr><td>signed fixedpoint</td><td>\s.N</td><td>For N &gt;=1. Signed Fixed-point with N fractional bits. The remaining bits are for the integral component.</td></tr>
</tbody></table>
</div>
<h3 id="print-and-print-state"><a class="header" href="#print-and-print-state"><code>print</code> and <code>print-state</code></a></h3>
<p>These commands allow inspecting <em>instance</em> state with optional formatting. Note
that this is different from breakpoints which operate on <em>definitions</em>. For example to print the ports of the <code>std_mul</code> instance named <code>mul</code> in the <code>pow</code> instance <code>pow_1</code> attached to the main component:</p>
<pre><code> &gt; print main.pow_1.mul
</code></pre>
<p>as with breakpoints, the leading <code>main</code> may be elided:</p>
<pre><code> &gt; print pow_1.mul
</code></pre>
<p>This will print all the ports attached to this multiplier instance with binary
formatting.</p>
<p>Formatting codes may be supplied as the first argument.</p>
<pre><code> &gt; print \u pow_1.mul
</code></pre>
<p>The <code>print</code> may also target specific ports on cells, rather than just the cell
itself. To see only the output of the multiplier (with unsigned formatting):</p>
<pre><code> &gt; print \u pow_1.mul.out
</code></pre>
<p>The <code>print-state</code> command works in the same way as the <code>print</code> command, except
it displays the internal state of a cell, rather than port values. As such, it
can only target cells and only those with some internal state, such as registers
or memories. For example, if the main component has a memory named <code>out_mem</code> its
contents may be viewed via:</p>
<pre><code> &gt; print-state main.out_mem
</code></pre>
<p>or just</p>
<pre><code> &gt; print-state out_mem
</code></pre>
<p>As with <code>print</code>, <code>print-state</code> supports formatting codes as an optional first
argument. So to view the contents of <code>out_mem</code> with a signed interpretation:</p>
<pre><code> &gt; print-state \s out_mem
</code></pre>
<h2 id="watchpoints"><a class="header" href="#watchpoints">Watchpoints</a></h2>
<p>Watchpoints are like breakpoints but rather than stop the execution when they
are passed, they instead print out some information. Like breakpoints, they are
set on group <em>definitions</em>, such as <code>main::group_1</code> or <code>pow::do_mul</code></p>
<h3 id="setting-watchpoints"><a class="header" href="#setting-watchpoints">Setting watchpoints</a></h3>
<p>The general form of watchpoints looks like</p>
<pre><code>watch [POSITION] GROUP with PRINT-COMMAND
</code></pre>
<p>where:</p>
<ul>
<li><code>GROUP</code> is the group definition to be watched</li>
<li><code>PRINT-COMMAND</code> is a full <code>print</code> or <code>print-state</code> command to be run by the watchpoint</li>
</ul>
<p>The optional <code>POSITION</code> argument may either be <code>before</code> or <code>after</code>. This
specifies whether the watchpoint should run when the group first becomes active
(<code>before</code>) or when the group finishes running (<code>after</code>). This defaults to
<code>before</code> if not set.</p>
<h3 id="managing-watchpoints"><a class="header" href="#managing-watchpoints">Managing watchpoints</a></h3>
<p>Watchpoint management is similar to breakpoints. However there may be multiple
watchpoints for a single group definition, so deleting watchpoints via the group
name will delete all the watchpoints associated with the group. Watchpoints do
not currently have an enable/disable state.</p>
<p>To view all the watchpoint definitions:</p>
<pre><code> &gt; info watch

...

 &gt; iw
</code></pre>
<p>To delete watchpoints:</p>
<pre><code> &gt; delete-watch 1
 &gt; del-watch main::group_1
</code></pre>
<h2 id="viewing-the-program-counter"><a class="header" href="#viewing-the-program-counter">Viewing the program counter</a></h2>
<p>There <code>where</code> command (alias <code>pc</code>) displays the currently running portion of the
control tree including active subcomponents. This can be used to more easily
determine the currently active portion of the design as well as visualize how
much of the execution is occurring in parallel at any given point.</p>
<h2 id="exiting-the-debugger"><a class="header" href="#exiting-the-debugger">Exiting the debugger</a></h2>
<p>Use <code>help</code> to see all commands. Use <code>exit</code> to exit the debugger.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-compilation-bugs"><a class="header" href="#debugging-compilation-bugs">Debugging Compilation Bugs</a></h1>
<p>These tips are directed towards <em>compilation bugs</em>. Before trying these, make sure your program
produces the correct values with the <a href="debug/../interpreter.html">Calyx Interpreter</a></p>
<h2 id="disabling-optimizations"><a class="header" href="#disabling-optimizations">Disabling Optimizations</a></h2>
<p>The first step is disabling optimization passes and running the bare bones compilation pipeline.</p>
<p>To disable the passes, add the flag <code>-p no-opt</code> to compiler invocation:</p>
<ol>
<li>For the compiler: <code>futil &lt;filename&gt; -p no-opt</code>.</li>
<li>For <code>fud</code>: <code>fud ... -s futil.flags &quot; -p no-opt&quot;</code>.</li>
</ol>
<p>If the output is still incorrect then one of the core compilation passes is incorrect.
Our best bet at this point is to reduce the test file such that the output from the
interpreter and the Calyx compiler still disagree and <a href="https://github.com/cucapra/calyx/issues/new">report the
bug</a>. We can use the <a href="debug/debug.html#waveform-debugging">waveform
debugging</a> to figure out which part of the compilation pipeline generates the
incorrect result.</p>
<p>If the execution generates the right result, then one of the optimizations
passes is incorrect.
To identify which optimization pass is wrong, add back individual passes and see
when the execution fails.
The <code>calyx/src/default_passes.rs</code> file defines the compilation pipeline. Start by incrementally
adding passes to this flag invocation:</p>
<pre><code>-p validate -p remove-comb-groups -p &lt;PASS 1&gt; ... -p &lt;PASS N&gt; -p compile -p lower
</code></pre>
<h2 id="reducing-test-files"><a class="header" href="#reducing-test-files">Reducing Test Files</a></h2>
<p>It is often possible to reduce the size of the example program that is
generating incorrect results.
In order to perform a reduction, we need to run the program twice, once with
a &quot;golden workflow&quot; that we trust to generate the right result and once with
the buggy workflow.</p>
<p>For example, if we've identified the problem to be in one of the Calyx passes,
the &quot;golden workflow&quot; is running the program without the pass while the buggy
workflow is running the program with the pass enabled.
This case is so common that we've written <a href="https://github.com/cucapra/calyx/blob/master/tools/flag-compare.sh">a script</a> that can run
programs with different set of flags to the Calyx compiler and show the
difference in the outputs after simulation.</p>
<p>The script is invoked as:</p>
<pre><code>tools/flag-compare.sh &lt;calyx program&gt; &lt;data&gt;
</code></pre>
<p>By default, the script will try to run the programs by simulating them through
Verilator by providing <code>fud</code> with the target <code>--to dat</code>.
If you'd like to use the Calyx Interpreter instead, run the following command:</p>
<pre><code>tools/flag-compare.sh &lt;calyx program&gt; &lt;data&gt; interpreter-out
</code></pre>
<h3 id="reducing-calyx-programs"><a class="header" href="#reducing-calyx-programs">Reducing Calyx Programs</a></h3>
<p>The best way to reduce Calyx program deleting group enables from the control
program and seeing if the generated program still generates the wrong output.
While doing this, make sure that you're not deleting an update to a loop
variable which might cause infinite loops.</p>
<p>By default, the compiler will complain if the program contains a <code>group</code> that
is not used in the control program which can get in the way of minimizing
programs.
To get around this, run the <a href="https://docs.calyxir.org/source/calyx/passes/struct.DeadGroupRemoval.html"><code>dead-group-removal</code></a> pass before the validation
passes:</p>
<pre><code>futil -p dead-group-removal -p validate ...
</code></pre>
<h3 id="reducing-dahlia-programs"><a class="header" href="#reducing-dahlia-programs">Reducing Dahlia Programs</a></h3>
<p>If you're working with Dahlia programs, it is also possible to reduce the
program with the script since it simply uses <code>fud</code> to run the program with the
simulator.
As with Calyx reduction, try deleting parts of the program and seeing if the
flag configurations for the Calyx program still generate different outputs.</p>
<h2 id="waveform-debugging-1"><a class="header" href="#waveform-debugging-1">Waveform Debugging</a></h2>
<p>Waveform debugging is the final way of debugging Calyx programs.
A waveform captures the value of every port at every clock cycle and can be
viewed using a wave viewer program like <a href="http://gtkwave.sourceforge.net/">GTKWave</a> or
<a href="https://marketplace.visualstudio.com/items?itemName=wavetrace.wavetrace">WaveTrace</a> to look at the wave form.
Because of this level of granularity, it generates a lot of information.
To make the information a little more digestible, we can use information
generated by Calyx during compilation.</p>
<p>For waveform debugging, we recommend disabling the optimization passes and
static timing compilation (unless you're debugging these passes).
In this debugging strategy, we'll do the following:</p>
<ol>
<li>Dump out the control FSM for the program we're debugging.</li>
<li>Find the FSM states that enable the particular groups that might be misbehaving.</li>
<li>Open the waveform viewer and find clock cycles where the FSM takes the corresponding
values and identify other signals that we care about.</li>
</ol>
<p>Consider the control section from <a href="https://github.com/cucapra/calyx/blob/master/examples/futil/dot-product.futil">examples/futil/dot-product.futil</a>:</p>
<pre><code>    seq {
      let0;
      while le0.out with cond0 {
        seq {
          par {
            upd0;
            upd1;
          }
          let1;
          let2;
          upd2;
          upd3;
        }
      }
    }
</code></pre>
<p>Suppose that we want to make sure that <code>let0</code> is correctly performing its
computation.
We can generate the control FSM for the program using:</p>
<pre><code>  futil &lt;filename&gt; -p top-down-cc
</code></pre>
<p>This generates a Calyx program with several new groups.
We want to look for groups with the prefix <code>tdcc</code> which look something like
this:</p>
<pre><code>group tdcc {
  let0[go] = !let0[done] &amp; fsm.out == 4'd0 ? 1'd1;
  cs_wh.in = fsm.out == 4'd1 ? le0.out;
  cs_wh.write_en = fsm.out == 4'd1 ? 1'd1;
  cond0[go] = fsm.out == 4'd1 ? 1'd1;
  par[go] = !par[done] &amp; cs_wh.out &amp; fsm.out == 4'd2 ? 1'd1;
  let1[go] = !let1[done] &amp; cs_wh.out &amp; fsm.out == 4'd3 ? 1'd1;
  let2[go] = !let2[done] &amp; cs_wh.out &amp; fsm.out == 4'd4 ? 1'd1;
  upd2[go] = !upd2[done] &amp; cs_wh.out &amp; fsm.out == 4'd5 ? 1'd1;
  upd3[go] = !upd3[done] &amp; cs_wh.out &amp; fsm.out == 4'd6 ? 1'd1;
  ...
}
</code></pre>
<p>The assignments to <code>let0[go]</code> indicate what conditions make the <code>let0</code> group
execute.
In this program, we have:</p>
<pre><code>let0[go] = !let0[done] &amp; fsm.out == 4'd0 ? 1'd1;
</code></pre>
<p>Which states that <code>let0</code> will be active when the state of the <code>fsm</code> register
is <code>0</code> along with some other conditions.
The remainder of the group defines how the state in the <code>fsm</code> variable changes:</p>
<pre><code>  ...
  fsm.in = fsm.out == 4'd0 &amp; let0[done] ? 4'd1;
  fsm.write_en = fsm.out == 4'd0 &amp; let0[done] ? 1'd1;
  fsm.in = fsm.out == 4'd1 &amp; cond0[done] ? 4'd2;
  fsm.write_en = fsm.out == 4'd1 &amp; cond0[done] ? 1'd1;
  ...
</code></pre>
<p>For example, we can see that when the value of the FSM is 0 and <code>let0[done]</code>
becomes high, the FSM will take the value 1.</p>
<p>Once we have this information, we can open the VCD file and look at points when
the <code>fsm</code> register has the value 1 and check to see if the assignments in
<code>let0</code> activated in the way we expected.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="emitting-calyx-from-python"><a class="header" href="#emitting-calyx-from-python">Emitting Calyx from Python</a></h1>
<p>Our frontends are written in Python3 and make use of the <code>calyx</code> library to
generate their code.</p>
<p>To install the library, run the following from the repository root (requires
<a href="https://flit.readthedocs.io/en/latest/">flit</a> installation):</p>
<pre><code>cd calyx-py &amp;&amp; flit install -s
</code></pre>
<p>The library provides an example:</p>
<pre><code>python calyx-py/test/example.py
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-frontend-for-calyx"><a class="header" href="#building-a-frontend-for-calyx">Building a Frontend for Calyx</a></h1>
<p>In this tutorial, we're going to build a compiler for a small language called MrXL.</p>
<h2 id="mrxl-overview"><a class="header" href="#mrxl-overview">MrXL Overview</a></h2>
<p>MrXL provides constructs to create arrays, and perform <code>map</code> and <code>reduce</code> operations on those arrays. Here's an example of a dot product implementation in MrXL:</p>
<pre><code>input avec: int[4]
input bvec: int[4]
output dot: int
prodvec := map 1 (a &lt;- avec, b &lt;- bvec) { a * b }
dot := reduce 1 (a, b &lt;- prodvec) 0 { a + b }
</code></pre>
<p>A <code>map</code> expressions produces a new vector, each element an evaluated expression that can use elements of other vectors. In the above example, the <code>map</code> expression multiplies the values of <code>avec</code> and <code>bvec</code>. These expressions also have <em>parallelism factors</em>: in the above code snippet, the <code>map</code> expression has a parallelism factor of 16, which means we stamp out 16 multipliers to speed up the computation.</p>
<p><code>reduce</code> expressions walk over memories and accumulate a result into a register. In the above code snippet, we add together all of the elements of <code>prodvec</code> and place them in a register named <code>dot</code>.</p>
<p>Arrays can be <code>input</code> arrays, which we populate with some input data, or <code>output</code> arrays, which the program will populate for us.</p>
<h2 id="run-a-mrxl-program"><a class="header" href="#run-a-mrxl-program">Run a MrXL Program</a></h2>
<p>First, you'll need to have the MrXL stage installed for <code>fud</code>. See the <a href="https://github.com/cucapra/futil/tree/master/frontends/mrxl">MrXL docs</a>.</p>
<p>MrXL programs need to be fed data in the form of JSON files. Let's try to run this program, which has a parallelism factor of two:</p>
<pre><code>input foo: int[4]
output baz: int[4]
baz := map 2 (a &lt;- foo) { a + 5 }
</code></pre>
<p>with this data file, containing banked memories to allow for the parallelism:</p>
<pre><code>{
  &quot;foo_b0&quot;: {
    &quot;data&quot;: [
      1,
      2
    ],
    &quot;format&quot;: {
      &quot;numeric_type&quot;: &quot;bitnum&quot;,
      &quot;is_signed&quot;: false,
      &quot;width&quot;: 32
    }
  },
  &quot;foo_b1&quot;: {
    &quot;data&quot;: [
      3,
      4
    ],
    &quot;format&quot;: {
      &quot;numeric_type&quot;: &quot;bitnum&quot;,
      &quot;is_signed&quot;: false,
      &quot;width&quot;: 32
    }
  },
  &quot;baz_b0&quot;: {
    &quot;data&quot;: [
      0,
      0
    ],
    &quot;format&quot;: {
      &quot;numeric_type&quot;: &quot;bitnum&quot;,
      &quot;is_signed&quot;: false,
      &quot;width&quot;: 32
    }
  },
  &quot;baz_b1&quot;: {
    &quot;data&quot;: [
      0,
      0
    ],
    &quot;format&quot;: {
      &quot;numeric_type&quot;: &quot;bitnum&quot;,
      &quot;is_signed&quot;: false,
      &quot;width&quot;: 32
    }
  }
}
</code></pre>
<p>Run the program with the supplied data by typing:</p>
<pre><code>fud exec frontends/mrxl/test/add.mrxl --from mrxl --to vcd -s verilog.data frontends/mrxl/test/add.mrxl.data
</code></pre>
<h2 id="build-a-compiler-for-mrxl"><a class="header" href="#build-a-compiler-for-mrxl">Build a Compiler for MrXL</a></h2>
<p>This guide will walk you through the steps to build a Python program that compiles MrXL programs to Calyx code. To simplify things, we'll make a few assumptions:</p>
<ul>
<li>Every array in a MrXL program has the same length.</li>
<li>Every integer in our generated hardware will be 32 bits.</li>
<li>Every <code>map</code> and <code>reduce</code> body will be either a multiplication or addition of either an array element or an integer.</li>
</ul>
<p>The following sections will outline these two high level tasks:</p>
<ol>
<li>Parse MrXL into a representation we can process with Python</li>
<li>Generate Calyx code</li>
</ol>
<h3 id="parse-mrxl-into-an-ast"><a class="header" href="#parse-mrxl-into-an-ast">Parse MrXL into an AST</a></h3>
<p>To start, we'll parse this MrXL program into a Python AST representation. We chose to represent <a href="https://github.com/cucapra/futil/blob/mrxl/mrxl/mrxl/ast.py">AST</a> nodes with Python <code>dataclass</code>s. Our toplevel AST node looks like this:</p>
<pre><code>@dataclass
class Prog:
    decls: List[Decl]
    stmts: List[Stmt]
</code></pre>
<p><code>Decl</code> nodes correspond to array declarations like <code>input avec: int[1024]</code>, and carry data about whether they're an <code>input</code> or <code>output</code> array, their name, and their type:</p>
<pre><code>@dataclass
class Decl:
    input: bool  # Otherwise, output.
    name: str
    type: Type
</code></pre>
<p><code>Stmt</code> nodes represent statements such as <code>dot := reduce 4 (a, b &lt;- prodvec) 0 { a + b }</code>, and contain more nested nodes representing their function header and body, and type of operation.</p>
<p>Now we can decide on rules for generating code depending on which AST node we're working on. Depending on the AST node, we might need to add code to <code>cells</code>, <code>wires</code> or <code>control</code>.</p>
<h3 id="generate-calyx-code"><a class="header" href="#generate-calyx-code">Generate Calyx Code</a></h3>
<p>The skeleton of a Calyx program has three sections, and looks like this:</p>
<pre><code>component main() -&gt; {
  cells { }
  wires { }
  control { }
}
</code></pre>
<p><code>cells</code> contains declarations for logical hardware units like adders, memories and registers. <code>wires</code> contains <code>group</code>s that connect together the units declared in <code>cell</code>s and form the structure of the hardware. <code>control</code> contains the logic specifying when the <code>group</code>s will perform their computation. Walking the nodes of the AST we defined earlier, we'll generate strings that we'll insert into each of these sections. The next few sections will discuss the different node types.</p>
<h4 id="decl-nodes"><a class="header" href="#decl-nodes"><code>Decl</code> nodes</a></h4>
<p><code>Decl</code> nodes instantiate new memories and registers. We need these to be instantiated in the <code>cells</code> section of our Calyx output. Here's Calyx code that creates a new memory <code>foo</code>, with 4 32-bit elements and a 32-bit indexor:</p>
<pre><code>foo = std_mem_d1(32, 4, 32);
</code></pre>
<p>For each <code>Decl</code> node, we need to determine if we're instantiating a memory or a register, and then translate that to a corresponding Calyx declaration and place that inside the <code>cells</code> section of our generated program. Here's some code from our compiler that walks through each register and memory declaration, and generates a Calyx program with those registers:</p>
<p>def emit(prog):
&quot;&quot;&quot;
Returns a string containing a Calyx program, compiled from <code>prog</code>, a MrXL
program.
&quot;&quot;&quot;
cells, wires, control = [], [], []</p>
<p>(<code>emit_mem_decl</code> emits a string of the form <code>&quot;mem_name = std_mem_d1(&lt;element_width&gt;, &lt;num_elements&gt;, &lt;index_width&gt;)&quot;</code>.)</p>
<h4 id="map-and-reduce-nodes"><a class="header" href="#map-and-reduce-nodes"><code>Map</code> and <code>Reduce</code> nodes</a></h4>
<p>For every map or reduce node, we need to generate Calyx code that iterates over an array, performs some kind of computation, and then stores the result of that computation. For <code>map</code> operations, we'll perform a computation on an element of an input array, and then store the result in a result array. For <code>reduce</code> operations, we'll also use an element of an input array, but we'll also use an <em>accumulator</em> register that we'll use in each computation, and we'll also store to. For example, if we were writing a <code>reduce</code> that summed up the elements of an input array, we'd use an accumulator register that was initialized to hold the value 0, and add to the value of this register each element of an input array.</p>
<p>We can implement these behaviors using Calyx groups:</p>
<ul>
<li><code>incr_idx</code>: Increments an <code>idx</code> register using an adder. This group is done when the <code>idx</code> register is written to.</li>
<li><code>cond</code>: Applies a &quot;less than&quot; operator to <code>idx</code>, and the length of our input arrays, using the <code>le</code> hardware unit.</li>
<li><code>eval_body</code>: Reads from an array, performs some kind of computation, and writes the result of the computation to an accumulator register or another array.</li>
</ul>
<p>We'll make these groups for each <code>Map</code> and <code>Reduce</code> node, so to avoid naming collisions, we'll suffix each group with an integer starting at 0, incrementing each time we need to add a new set of  groups. These groups will be added to the <code>wires</code> section. We'll also need to add logic to the <code>control</code> section as well that uses these groups to process arrays:</p>
<pre><code>while le0.out with cond0 {
  seq { eval_body0; incr_idx0; }
}
</code></pre>
<p>This logic orchestrates our groups, basically representing iterating over our array and evaluating some computation on each element of the array. On each iteration we signal for the <code>eval_body0</code> group to do its work, followed sequentially by <code>incr_idx0</code> to advance our index register so that we can work on the next element of the array.</p>
<h3 id="add-parallelization"><a class="header" href="#add-parallelization">Add Parallelization</a></h3>
<p>MrXL allows you to parallelize your <code>map</code> and <code>reduce</code> operations. Let's revisit the <code>map</code> example from earlier:</p>
<pre><code>input foo: int[4]
output baz: int[4]
baz := map 4 (a &lt;- foo) { a + 5 }
</code></pre>
<p>The number 4 after the <code>map</code> specifies the number of adders we can use at once to parallelize this computation. There are a few ways we could parallelize this program, and one of them is to split the memories used in the <code>map</code> operation into 4 separate memory <em>banks</em>, and then we can read from each bank of <code>foo</code> and write into each bank of <code>baz</code> simultaneously. In general, we can break memories of size <code>m</code> into <code>b</code> banks (each with size <code>m/b</code>), and then simultaneously process those <code>b</code> banks. Realizing this in Calyx means creating separate memories for each bank, and creating <code>group</code>s to process each bank. Here's a section of the compiler that generates banked memories:</p>
<pre><code>    Group,
    CompVar,
    Stdlib,
    Cell,
    Program,
    Component,
    Import,
    SeqComp,
    ConstantPort,
    HolePort,
    CompPort,
    Enable,
    While,
    ParComp,
    CombGroup,
</code></pre>
<p>In the <code>Map</code> and <code>Reduce</code> code generation section we described <code>group</code>s that could be orchestrated to iterate over a memory and process it. We'll now have to do that for each memory bank, and then parallelize these operations in the generated Calyx's <code>control</code> section. We can accomplish this with Calyx's <code>par</code> keyword, signalling to execute groups in parallel. Here's an example of executing four while loops in parallel:</p>
<pre><code>par {
  while le_b0.out with cond_b0 { seq { eval_body_b0; incr_idx_b0; } }
  while le_b1.out with cond_b1 { seq { eval_body_b1; incr_idx_b1; } }
  while le_b2.out with cond_b2 { seq { eval_body_b2; incr_idx_b2; } }
  while le_b3.out with cond_b3 { seq { eval_body_b3; incr_idx_b3; } }
}
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Hopefully this should be enough to get you started with writing your own MrXL compiler. Some more follow up tasks you could try if you're interested:</p>
<ul>
<li>Implement code generation to implement <code>reduce</code> statements, which we do not include in our compiler.</li>
<li>Implement code generation that allows memories that differ from one another in size.</li>
<li>Implement complex function body expressions. We only support binary operations with simple operands, like <code>a + 5</code>. Different hardware components take multiple cycles to execute: for example, a register takes 1 cycle to write data to, but a memory might take more. This complicates hardware design, as you need to account for differing latencies among hardware components.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frontend-compilers"><a class="header" href="#frontend-compilers">Frontend Compilers</a></h1>
<p>Several compiler generate Calyx programs from other high-level languages.</p>
<ul>
<li><a href="frontends/./dahlia.html">Dahlia</a>: Dahlia is an imperative, loop-based programming language.</li>
<li><a href="frontends/./systolic-array.html">Systolic Array Generator</a>: Generates systolic arrays using parameters.</li>
<li><a href="frontends/./tvm-relay.html">TVM Relay</a>: Relay is an IR for the TVM framework to replace old computation graph based IRs.</li>
<li><a href="frontends/./ntt.html">NTT Pipeline Generator</a>: Generates a pipeline for the number theoretic transform.</li>
<li><a href="frontends/./mrxl.html">MrXL</a>: A simple example frontend developed in the <a href="frontends/../tutorial/frontend-tut.html">frontend tutorial</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dahlia"><a class="header" href="#dahlia">Dahlia</a></h1>
<p><a href="https://capra.cs.cornell.edu/dahlia">Dahlia</a> is an imperative, loop-based programming language for designing
hardware accelerators.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>First, install <a href="https://www.scala-sbt.org/1.x/docs/Setup.html">sbt</a> and <a href="https://docs.scala-lang.org/getting-started/index.html">scala</a>.</p>
<p>Then, clone the repository and build the Dahlia compiler:</p>
<pre><code>git clone https://github.com/cucapra/dahlia.git
cd dahlia
sbt install
sbt assembly
chmod +x ./fuse
</code></pre>
<p>The Dahlia compiler can be run using the <code>./fuse</code> binary:</p>
<pre><code>./fuse --help
</code></pre>
<p>Finally, configure <code>fud</code> to use the Dahlia compiler:</p>
<pre><code>fud c stages.dahlia.exec &lt;path to Dahlia repository&gt;/fuse
</code></pre>
<p>Use <code>fud</code> to check if the compiler was installed correctly:</p>
<pre><code>fud check
</code></pre>
<p><code>fud</code> should report that the Dahlia compiler is available and has the right
version.</p>
<p>If something went wrong, try following the <a href="https://github.com/cucapra/dahlia#set-it-up">instructions</a> to build the Dahlia
compiler from its repository.</p>
<h2 id="compiling-dahlia-to-calyx"><a class="header" href="#compiling-dahlia-to-calyx">Compiling Dahlia to Calyx</a></h2>
<p>Dahlia programs can be compiled to Calyx using:</p>
<pre><code>fud e --from dahlia &lt;input file&gt; --to futil
</code></pre>
<p>The Dahlia backed for Calyx is neither <em>complete</em> nor <em>stable</em>. If you find
a confusing error or wrong program, please open an <a href="https://github.com/cucapra/dahlia/issues">issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systolic-array"><a class="header" href="#systolic-array">Systolic Array</a></h1>
<p>Systolic arrays are commonly used to implement fast linear-algebra
computations. See <a href="http://www.eecs.harvard.edu/%7Ehtk/publication/1982-kung-why-systolic-architecture.pdf">this paper</a> for an overview on
systolic arrays.</p>
<p>The systolic array frontend lives in the <a href="https://github.com/cucapra/calyx/tree/master/frontends/systolic-lang">systolic-lang</a> folder in the
Calyx repository and generates systolic arrays that can perform matrix
multiplies.</p>
<p>The <code>gen-systolic.py</code> contains the entire program required to generate
systolic arrays. In order to generate an <em>8 X 8</em> systolic array, run:</p>
<pre><code>./frontends/systolic-lang/gen-systolic.py -tl 8 -td 8 -ll 8 -ld 8
</code></pre>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>Install the <a href="frontends/../calyx-py.html">calyx-py</a> library.</p>
<h2 id="command-line-options"><a class="header" href="#command-line-options">Command Line Options</a></h2>
<p>The command line options configure the dimensions of the generated
systolic array. There are no other properties of the systolic array that
can be configured.</p>
<ul>
<li><code>--top-length</code>, <code>--left-length</code>: The length of top and left sides of the systolic array.</li>
<li><code>--top-depth</code>, <code>--left-depth</code>: The length of the input streams from top and left sides of the array.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tvm-relay"><a class="header" href="#tvm-relay">TVM Relay</a></h1>
<p><a href="https://tvm.apache.org">TVM</a> is a compiler for machine learning frameworks that can
optimize and target kernels to several different backends. <a href="https://tvm.apache.org/docs/api/python/relay/index.html">Relay</a>
is a high level intermediate representation for the TVM framework.
The goal of Relay is to replace old computation graph based
IRs with a more expressive IR.
More information can be found in <a href="https://arxiv.org/abs/1904.08368">this paper</a>.</p>
<p>The TVM Relay frontend lives in the <a href="https://github.com/cucapra/calyx/tree/master/frontends/relay">relay-lang</a> folder in the
Calyx repository and generates Calyx components from the Relay
intermediate representation.</p>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<ol>
<li>
<p>Clone the TVM repository with commit hash <code>ccacb1ec1</code>):</p>
<pre><code> git clone --recursive git@github.com:apache/incubator-tvm.git
 cd incubator-tvm &amp;&amp; git checkout ccacb1ec1
</code></pre>
</li>
<li>
<p>Set up to build (the default configuration is fine because we don't need any fancy backends like LLVM or CUDA):</p>
<pre><code> mkdir build &amp;&amp; cd build
 cp ../cmake/config.cmake .
</code></pre>
</li>
<li>
<p>Build TVM:</p>
<pre><code> cmake -G Ninja .. &amp;&amp; ninja
</code></pre>
</li>
<li>
<p>Install the <code>tvm</code> Python package by building a <a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/#wheels">wheel</a>:</p>
<pre><code> cd ../python &amp;&amp; python3 setup.py bdist_wheel
 pip3 install --user dist/tvm-*.whl
</code></pre>
</li>
<li>
<p>Install the accompanying <code>topi</code> Python package:</p>
<pre><code> cd ../topi/python &amp;&amp; python3 setup.py bdist_wheel
 pip3 install --user dist/topi-*.whl
</code></pre>
</li>
<li>
<p>Install ANTLR v4.7.2 (required for the Relay text format parser):</p>
<pre><code> pip3 install -Iv antlr4-python3-runtime==4.7.2
</code></pre>
</li>
<li>
<p>To run the <a href="https://github.com/apache/incubator-tvm/blob/main/python/tvm/relay/testing/mlp.py">MLP net</a> and <a href="https://github.com/apache/incubator-tvm/blob/main/python/tvm/relay/testing/vgg.py">VGG net</a> examples, install <code>pytest</code>:</p>
<pre><code> pip3 install pytest
</code></pre>
</li>
<li>
<p>Install <a href="https://github.com/cucapra/dahlia#set-it-up">Dahlia</a>, which is used when lowering Relay call nodes to Calyx.</p>
</li>
<li>
<p>Install the <a href="frontends/../calyx-py.html">calyx-py</a> library.</p>
</li>
</ol>
<h2 id="run-an-example"><a class="header" href="#run-an-example">Run an Example</a></h2>
<p>Try this to run a simple example:</p>
<pre><code>cd calyx/frontends/relay
python3 example.py tensor_add
</code></pre>
<ul>
<li><code>-h</code>: Help option; shows available examples.</li>
<li><code>-r</code>: Dumps the Relay IR. Otherwise, it dumps the Calyx output.</li>
</ul>
<h2 id="simulate-an-onnx-model"><a class="header" href="#simulate-an-onnx-model">Simulate an ONNX Model</a></h2>
<p>A simple script is provided to run an Open Neural Network Exchange (ONNX) model.
In addition to installing TVM Relay above, you'll need the following PIP installations
for ONNX simulation and image pre-processing:</p>
<pre><code>pip3 install opencv-python Pillow mxnet onnx simplejson
</code></pre>
<p>For example, we can simulate the LeNet ONNX model found <a href="https://github.com/ekut-es/pico-cnn/blob/master/data/lenet/lenet.onnx">here</a> using the following command:</p>
<pre><code>python3 frontends/relay/onnx_to_calyx.py \ 
-n &quot;lenet&quot; \ 
-d &quot;MNIST&quot; \ 
-i &quot;/path/to/image.png&quot; \
-onnx &quot;/path/to/model.onnx&quot; \ 
-o calyx
</code></pre>
<ul>
<li><code>-n</code>: The name of the input net. This is mostly used for naming the output files.</li>
<li><code>-d</code>: The dataset for which the input will be classified against. This is necessary to 
determine what preprocessing should be done on the image. e.g. <code>&quot;mnist&quot;</code> or <code>&quot;imagenet&quot;</code>.</li>
<li><code>-i</code>: The file path to the input image which you want classified.</li>
<li><code>-onnx</code>: The file path to the ONNX model.</li>
<li><code>-o</code>: The type of output. 
<ol>
<li><code>tvm</code>: Executes the ONNX model using the TVM executor. Prints the final softmax value 
to console. No postprocessing is conducted.</li>
<li><code>relay</code>: Output a file with the corresponding Relay program. <code>&lt;net_name&gt;.relay</code> </li>
<li><code>calyx</code>: Output a <code>.data</code> file and Calyx program for simulation. <code>&lt;net_name&gt;.futil</code>, <code>&lt;net_name&gt;.data</code></li>
<li><code>all</code>: All the above.</li>
</ol>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-theoretic-transform-ntt"><a class="header" href="#number-theoretic-transform-ntt">Number Theoretic Transform (NTT)</a></h1>
<p>The number theoretic transform is a generalization of the
fast Fourier transform that uses nth primitive root of unity
based upon a quotient ring instead of a field of complex numbers.</p>
<p>It is commonly used to speed up computer arithmetic, such as the
multiplication of large integers and large degree polynomials. The
pipeline produced here is based upon <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/05/RLWE-1.pdf">this paper</a>,
which also provides some background information on NTT.</p>
<p>The NTT pipeline frontend lives in the <a href="https://github.com/cucapra/calyx/tree/master/frontends/ntt-pipeline">ntt</a> folder in the
Calyx repository and generates the pipeline for the NTT transform.</p>
<p>The <code>gen-ntt-pipeline.py</code> file contains the entire program required to
generate NTT pipelines. In order to generate a pipeline with
bit width <code>32</code>, input size <code>4</code>, and modulus value <code>97</code>:</p>
<pre><code>./frontends/ntt-pipeline/gen-ntt-pipeline.py -b=32 -n=4 -q=97
</code></pre>
<h2 id="installation-4"><a class="header" href="#installation-4">Installation</a></h2>
<p>Install the <a href="frontends/../calyx-py.html">calyx-py</a> library.</p>
<p>The generator also produces a table to illustrate which operations are occurring
during each stage of the pipeline. This requires installing PrettyTable:</p>
<pre><code>pip3 install prettytable numpy
</code></pre>
<h2 id="fud-stage"><a class="header" href="#fud-stage">Fud Stage</a></h2>
<p>The NTT pipeline defines an [external fud stage][../fud/external.md] to
transform configuration files into Calyx programs.
To install, run:</p>
<pre><code>fud register ntt -p frontends/ntt-pipeline/fud/ntt.py &amp;&amp; fud check
</code></pre>
<p>This should report the newly installed <code>ntt</code> stage in the configuration.</p>
<h2 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h2>
<p>Configurations files simply specify command line parameters:</p>
<pre><code class="language-json">{
  &quot;input_bitwidth&quot;: 32,
  &quot;input_size&quot;: 4,
  &quot;modulus&quot;: 97
}
</code></pre>
<h2 id="command-line-options-1"><a class="header" href="#command-line-options-1">Command Line Options</a></h2>
<p>The command line options configure the bit width, size, and modulus value of the
pipeline.</p>
<ul>
<li><code>--input_bitwidth</code>: The bit width of each value in the input array.</li>
<li><code>--input_size</code>: The length (or size) of the input array.</li>
<li><code>--modulus</code>: The (prime) modulus value used during the transformation.</li>
<li><code>--parallel_reduction</code>: Decreases fan-out by reducing the number of groups executed in parallel by this factor.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mrxl"><a class="header" href="#mrxl">MrXL</a></h1>
<blockquote>
<p>The MrXL frontend is a toy frontend developed for the <a href="frontends/../tutorial/frontend-tut.html">frontend tutorial</a>. As such, it is less rigorously tested and might have bugs.</p>
</blockquote>
<p>MrXL is an example DSL for demonstrating Calyx. MrXL programs consist of <code>map</code> and <code>reduce</code> operations on arrays. For example, this is a dot product implementation:</p>
<pre><code>input avec: int[1024]
input bvec: int[1024]
output dot: int
prodvec := map 16 (a &lt;- avec, b &lt;- bvec) { a * b }
dot := reduce 4 (a, b &lt;- prodvec) 0 { a + b }
</code></pre>
<p>The numbers that come right after <code>map</code> and <code>reduce</code> are parallelism factors that guide the generation of hardware.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>Install the <a href="frontends/../calyx-py.html">calyx-py</a> library.</p>
<p>The MrXL implementation is in Python and uses <a href="https://flit.readthedocs.io/en/latest/index.html">Flit</a>.
First, <a href="https://flit.readthedocs.io/en/latest/index.html">install flit</a> (<code>pip install flit</code> or similar), and then type the
following inside <code>frontend/mrxl</code>:</p>
<pre><code>flit install --symlink
</code></pre>
<p>This creates a symbolic link the mrxl directory and installs the <code>mrxl</code> command
line tool.</p>
<p>By default, <a href="frontends/../fud">fud</a> looks for the <code>mrxl</code> executable to enable
the <code>mrxl</code> compilation stage.
Type <code>fud check</code> to make sure <code>fud</code> reports that the <code>mrxl</code> compiler has been
found.</p>
<h2 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h2>
<p>To run the interpreter, do this:</p>
<pre><code>mrxl &lt;program&gt; --data &lt;indata&gt; --interpret
</code></pre>
<p>where <code>&lt;program&gt;</code> is a MrXL source code file and <code>&lt;indata&gt;</code> is a JSON file containing values for all the variables declared as <code>input</code> in the program. The interpreter dumps the <code>output</code> variables as JSON to stdout.</p>
<p>You can try this, for example:</p>
<pre><code>mrxl test/dot.mrxl --data test/dot.json --interpret
</code></pre>
<h2 id="compiling-to-calyx"><a class="header" href="#compiling-to-calyx">Compiling to Calyx</a></h2>
<p>To run the compiler, leave off the <code>--interpret</code> and <code>--data</code> flags:</p>
<pre><code>mrxl test/dot.mrxl
</code></pre>
<p>In order to run the compiler through <code>fud</code>, pass the <code>--from mrxl</code> flag:</p>
<pre><code>fud e --from mrxl &lt;mrxl file&gt; --to futil
</code></pre>
<p>To simulate the Verilog generated from the mrxl compiler, set the <code>-s verilog.data</code> as usual:</p>
<pre><code>fud e --from mrxl &lt;mrxl file&gt; --to dat -s verilog.data &lt;data file&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runt"><a class="header" href="#runt">Runt</a></h1>
<p>Runt (Run Tests) is the expectation testing framework for Calyx. It organizes
collections of tests into test suites and specifies configuration for them.</p>
<p>Runt uses <code>runt.toml</code> to define the test suites and configure them.</p>
<h2 id="cheatsheet"><a class="header" href="#cheatsheet">Cheatsheet</a></h2>
<p>Runt workflow involves two things:</p>
<ol>
<li>Running tests and comparing differences</li>
<li>Saving new or changed golden files</li>
</ol>
<p>To run all the tests in a directory, run <code>runt</code> with a folder containing <code>runt.toml</code>.</p>
<p>The following commands help focus on specific tests to run:</p>
<ul>
<li><code>-i</code>: Include files that match the given pattern. The pattern is matched against <code>&lt;suite name&gt;:&lt;file path&gt;</code> so it can be used to filter both test suites or specific paths. General regex patterns are supported.</li>
<li><code>-x</code>: Exclude files that match the pattern</li>
<li><code>-o</code>: Filter out reported test results based on test status. Running with <code>miss</code> will only show the tests that don't have an <code>.expect</code> file.</li>
</ul>
<p><strong>Differences</strong>. <code>-d</code> or <code>--diff</code> shows differences between the expected test output and the generated output. Use this in conjunction with <code>-i</code> to focus on particular failing tests.</p>
<p><strong>Saving Files</strong>. <code>-s</code> is used to save test outputs when the have expected changes. In the case of <code>miss</code> tests, i.e. tests that currently don't any expected output file, this saves a completely new <code>.expect</code> file.</p>
<p><strong>Dry run</strong>. <code>-n</code> flag shows the commands that <code>runt</code> will run for each test. Use this when you directly want to run the command for the test directly.</p>
<p>For other options, look at <code>runt --help</code> which documents other features in <code>runt</code>.</p>
<p>For instruction on using runt, see the <a href="https://github.com/rachitnigam/runt#run-test-runt--">official documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exp-generator"><a class="header" href="#exp-generator"><code>exp</code> Generator</a></h1>
<p>The <code>exp</code> generator uses a Taylor series approximation to calculate the fixed point value of the natural
exponential function <code>e^x</code>. The <a href="https://en.wikipedia.org/wiki/Taylor_series#Exponential_function">Maclaurin series</a> 
for the function can be written as:</p>
<pre><code>e^x = 1 + x + x^2/2! + x^3/3! + ... + x^n/n!
</code></pre>
<p>where <code>n</code> is the nth degree or order of the polynomial.</p>
<p>For signed values, we can take the reciprocal value:</p>
<pre><code>e^(-x) = 1/e^x
</code></pre>
<p>The <code>gen_exp.py</code> file can generate an entire Calyx program for testing purposes.
The <code>main</code> component contains memories <code>x</code> (for the input) and <code>ret</code> for the result of <code>e^x</code>. 
In order to generate an example program with degree <code>4</code>, bit width <code>32</code>, integer bit width <code>16</code>, and <code>x</code> interpreted as a signed value:</p>
<pre><code>./calyx-py/calyx/gen_exp.py -d 4 -w 32 -i 16 -s true
</code></pre>
<p>Similarly, it provides a function to produce only the necessary components to be dropped into other Calyx programs.</p>
<h2 id="installation-5"><a class="header" href="#installation-5">Installation</a></h2>
<p>Install the <a href="tools/../calyx-py.html">calyx-py</a> library.</p>
<h2 id="command-line-options-2"><a class="header" href="#command-line-options-2">Command Line Options</a></h2>
<p>The command line options configure the degree (or order) of the taylor series, bit width, integer bit width, and sign.</p>
<ul>
<li><code>--degree</code>: The degree of the Taylor polynomial.</li>
<li><code>--width</code>: The bit width of the value <code>x</code>.</li>
<li><code>--int_width</code>: The integer bit width of the value <code>x</code>. The fractional bit width is then inferred as <code>width - int_width</code>.</li>
<li><code>--is_signed</code>: The signed interpretation of the value <code>x</code>. If <code>x</code> is a signed value, this should be <code>true</code> and otherwise, <code>false</code>. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-highlighting"><a class="header" href="#editor-highlighting">Editor Highlighting</a></h1>
<h2 id="vim"><a class="header" href="#vim">Vim</a></h2>
<p>The vim extension highlights files with the extension <code>.futil</code>. 
It can be installed using a plugin manager such as <a href="https://github.com/junegunn/vim-plug">vim-plug</a> using a
local installation.
Add the following to your vim plug configuration:</p>
<pre><code>Plug '&lt;path-to-calyx&gt;/tools/vim'
</code></pre>
<p>And run:</p>
<pre><code>:PlugInstall
</code></pre>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p><code>futil-mode</code> is implements highlighting for <code>.futil</code> files in emacs.
It is located in <code>&lt;repo&gt;/tools/emacs/futil-mode</code>.</p>
<p>Clone the repository, add the above path to your <a href="http://www.emacswiki.org/emacs/LoadPath">load path</a>, and require
<code>futil-mode</code>.
If you use <a href="https://www.spacemacs.org/">Spacemacs</a>, this looks like adding the following lines to
<code>dotspacemacs/user-config</code> in your <code>.spacemacs</code> file:</p>
<pre><code class="language-elisp">(push &quot;~/.emacs.d/private/local/fuse-mode&quot; load-path)
(require 'fuse-mode)
</code></pre>
<p>I imagine it looks very similar for pure emacs, but haven't actually tried it myself.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>Add a link to the Calyx VSCode extension directory to your VSCode extensions directory.</p>
<pre><code>cd $HOME/.vscode/extensions
ln -s &lt;calyx root directory/tools/vscode calyx.calyx-0.0.1
</code></pre>
<p>Restart VSCode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Here is a list of all the people who have worked on Calyx:</p>
<p><strong>Current Contributors</strong></p>
<ul>
<li><a href="https://sgtpeacock.com/">Sam Thomas</a></li>
<li><a href="https://rachitnigam.com">Rachit Nigam</a></li>
<li><a href="https://griffinberlste.in">Griffin Berlstein</a></li>
<li><a href="https://chrispg.dev">Chris Gyurgyik</a></li>
<li><a href="https://adriansampson.net">Adrian Sampson</a></li>
<li>YoungSeok Na</li>
<li><a href="https://jpramos.me">Jan-Paul Ramos</a></li>
<li>Jiaxuan (Crystal) Hu</li>
<li>Pai Li</li>
</ul>
<p><strong>Previous Contributors</strong></p>
<ul>
<li><a href="https://neiladit.com/">Neil Adit</a></li>
<li>Kenneth Fang</li>
<li><a href="https://tissue3.github.io/">Zhijing Li</a></li>
<li><a href="https://www.viviyye.com/">Yuwei Ye</a></li>
<li>Ted Bauer</li>
<li>YooNa Chang</li>
<li>Karen Zhang</li>
<li>Andrii Iermolaiev</li>
<li>Alma Thaler</li>
</ul>
<p>If you're missing from this list, please <a href="https://github.com/cucapra/futil/edit/master/docs/contributors.md">add yourself</a>!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
