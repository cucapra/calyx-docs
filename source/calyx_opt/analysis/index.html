<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Analysis for Calyx programs."><title>calyx_opt::analysis - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="calyx_opt" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.1 (4eb161250 2025-03-15)" data-channel="1.85.1" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../calyx_opt/index.html">calyx_<wbr>opt</a><span class="version">0.7.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module analysis</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate calyx_<wbr>opt</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">calyx_opt</a></span><h1>Module <span>analysis</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/calyx_opt/analysis/mod.rs.html#1-49">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Analysis for Calyx programs.</p>
<p>The analyses construct data-structures that make answering certain queries
about Calyx programs easier.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="reaching_defns/index.html" title="mod calyx_opt::analysis::reaching_defns">reaching_<wbr>defns</a></div><div class="desc docblock-short">Calculate the reaching definitions in a control program.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CompactionAnalysis.html" title="struct calyx_opt::analysis::CompactionAnalysis">Compaction<wbr>Analysis</a></div><div class="desc docblock-short">Struct to perform compaction on <code>seqs</code>.
It will only work if you update_cont_read_writes for each component that
you run it on.</div></li><li><div class="item-name"><a class="struct" href="struct.ControlId.html" title="struct calyx_opt::analysis::ControlId">Control<wbr>Id</a></div><div class="desc docblock-short">Adding “NODE_ID”, “BEGIN_ID”, and “END_ID” attribute to control statement</div></li><li><div class="item-name"><a class="struct" href="struct.ControlOrder.html" title="struct calyx_opt::analysis::ControlOrder">Control<wbr>Order</a></div><div class="desc docblock-short">Extract the dependency order of a list of control programs.
Dependencies are defined using read/write sets used in the control program.
The read/write sets ignore ports on constants and ThisComponent.</div></li><li><div class="item-name"><a class="struct" href="struct.ControlPorts.html" title="struct calyx_opt::analysis::ControlPorts">Control<wbr>Ports</a></div><div class="desc docblock-short">Contains a mapping from name of <a href="../../calyx_ir/structure/struct.CombGroup.html" title="struct calyx_ir::structure::CombGroup">ir::CombGroup</a> to the ports read by the control program
as well as the mapping from invoke statements to the port mappings.
The vector of ports is guaranteed to only contain unique ports.</div></li><li><div class="item-name"><a class="struct" href="struct.DataflowOrder.html" title="struct calyx_opt::analysis::DataflowOrder">Dataflow<wbr>Order</a></div><div class="desc docblock-short">Given a set of assignment, generates an ordering that respects combinatinal
dataflow.</div></li><li><div class="item-name"><a class="struct" href="struct.DominatorMap.html" title="struct calyx_opt::analysis::DominatorMap">Dominator<wbr>Map</a></div><div class="desc docblock-short">Builds a Domination Map for the control program. It maps nodes to sets of
nodes. Here is what is included as a “node” in the domination map:</div></li><li><div class="item-name"><a class="struct" href="struct.GoDone.html" title="struct calyx_opt::analysis::GoDone">GoDone</a></div><div class="desc docblock-short">Struct to store information about the go-done interfaces defined by a primitive.
There is no default implementation because it will almost certainly be very
unhelpful: you will want to use <code>from_ctx</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.GraphAnalysis.html" title="struct calyx_opt::analysis::GraphAnalysis">Graph<wbr>Analysis</a></div><div class="desc docblock-short">Constructs a graph based representation of a component. Each node represents
a <a href="../../calyx_ir/structure/struct.Port.html" title="struct calyx_ir::structure::Port"><code>ir::Port</code></a> and each directed edge (<code>X -&gt; Y</code>) means
that <code>X</code>’s value written to <code>Y</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.GraphColoring.html" title="struct calyx_opt::analysis::GraphColoring">Graph<wbr>Coloring</a></div><div class="desc docblock-short">Defines a greedy graph coloring algorithm over a generic conflict graph.</div></li><li><div class="item-name"><a class="struct" href="struct.InferenceAnalysis.html" title="struct calyx_opt::analysis::InferenceAnalysis">Inference<wbr>Analysis</a></div><div class="desc docblock-short">Default implemnetation is almost certainly not helpful.
You should probably use <code>from_ctx</code> instead.</div></li><li><div class="item-name"><a class="struct" href="struct.LiveRangeAnalysis.html" title="struct calyx_opt::analysis::LiveRangeAnalysis">Live<wbr>Range<wbr>Analysis</a></div><div class="desc docblock-short">This analysis implements a parallel version of a classic liveness analysis.
For each group or invoke, it returns a list of the state shareable cells
that are “alive” during an execution of a group or invoke statement (we
identify an invoke statement by the cell that is being invoked, and groups
by the name of the group).</div></li><li><div class="item-name"><a class="struct" href="struct.ParNodes.html" title="struct calyx_opt::analysis::ParNodes">ParNodes</a></div><div class="desc docblock-short">Represents a group of <code>Nodes</code> that execute in parallel.</div></li><li><div class="item-name"><a class="struct" href="struct.PortInterface.html" title="struct calyx_opt::analysis::PortInterface">Port<wbr>Interface</a></div><div class="desc docblock-short">Helper methods to parse <code>@read_together</code> and <code>@write_together</code> specifications</div></li><li><div class="item-name"><a class="struct" href="struct.PromotionAnalysis.html" title="struct calyx_opt::analysis::PromotionAnalysis">Promotion<wbr>Analysis</a></div></li><li><div class="item-name"><a class="struct" href="struct.ReadWriteSet.html" title="struct calyx_opt::analysis::ReadWriteSet">Read<wbr>Write<wbr>Set</a></div><div class="desc docblock-short">Calcuate the reads-from and writes-to set for a given set of assignments.</div></li><li><div class="item-name"><a class="struct" href="struct.ScheduleConflicts.html" title="struct calyx_opt::analysis::ScheduleConflicts">Schedule<wbr>Conflicts</a></div><div class="desc docblock-short">A conflict graph that describes which nodes (i.e. groups/invokes) are being run in parallel
to each other.</div></li><li><div class="item-name"><a class="struct" href="struct.ShareSet.html" title="struct calyx_opt::analysis::ShareSet">Share<wbr>Set</a></div><div class="desc docblock-short">Stores a Hashset that contains the type names of all components and primitives
marked with either “share” or “state_share”,depending on what the user wants.
Methods implemented by this struct can
be used to determine whether a given cell is shareable or not
Used by <code>live_range_analysis.rs</code>, <code>cell_share.rs</code>, and <code>infer_share.rs</code></div></li><li><div class="item-name"><a class="struct" href="struct.SingleNode.html" title="struct calyx_opt::analysis::SingleNode">Single<wbr>Node</a></div><div class="desc docblock-short"><code>SingleNode</code> struct.</div></li><li><div class="item-name"><a class="struct" href="struct.StaticFSM.html" title="struct calyx_opt::analysis::StaticFSM">StaticFSM</a></div><div class="desc docblock-short">Represents a static FSM (i.e., the actual register in hardware that counts)</div></li><li><div class="item-name"><a class="struct" href="struct.StaticParTiming.html" title="struct calyx_opt::analysis::StaticParTiming">Static<wbr>ParTiming</a></div><div class="desc docblock-short">Calculate live ranges across static par blocks.
Assumes control ids have already been given; it does not add its own</div></li><li><div class="item-name"><a class="struct" href="struct.VariableDetection.html" title="struct calyx_opt::analysis::VariableDetection">Variable<wbr>Detection</a></div><div class="desc docblock-short">Detects if a group is solely being used to update a register.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.FSMEncoding.html" title="enum calyx_opt::analysis::FSMEncoding">FSMEncoding</a></div></li><li><div class="item-name"><a class="enum" href="enum.Node.html" title="enum calyx_opt::analysis::Node">Node</a></div><div class="desc docblock-short">Node can either be a SingleNode (i.e., a single node) or ParNodes (i.e., a group of
nodes that are executing in parallel).
Most methods in <code>Node</code> simply call the equivalent methods for each
of the two possible variants.
Perhaps could be more compactly implemented as a Trait.</div></li><li><div class="item-name"><a class="enum" href="enum.StateType.html" title="enum calyx_opt::analysis::StateType">State<wbr>Type</a></div><div class="desc docblock-short">Helpful for translating queries for the FSMTree structure.
Because of the tree structure, %[i:j] is no longer is always equal to i &lt;= fsm &lt; j.
Offload(i) means the FSM is offloading when fsm == i: so if the fsm == i,
we need to look at the children to know what cycle we are in exactly.
Normal(i,j) means the FSM is outputing (i..j), incrementing each cycle (i.e.,
like normal) and not offloading. Note that even though the FSM is outputting
i..j each cycle, that does not necesarily mean we are in cycles i..j (due
to offloading performed in the past.)</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AssignmentAnalysis.html" title="trait calyx_opt::analysis::AssignmentAnalysis">Assignment<wbr>Analysis</a></div><div class="desc docblock-short">Analyzes that can be performed on a set of assignments.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoStatic.html" title="trait calyx_opt::analysis::IntoStatic">Into<wbr>Static</a></div></li><li><div class="item-name"><a class="trait" href="trait.WithStatic.html" title="trait calyx_opt::analysis::WithStatic">With<wbr>Static</a></div><div class="desc docblock-short">Trait to propagate and extra “static” attributes through <a href="../../calyx_ir/control/enum.Control.html" title="enum calyx_ir::control::Control">ir::Control</a>.
Calling the update function ensures that the current program, as well as all
sub-programs have a “static” attribute on them.
Usage:</div></li></ul></section></div></main></body></html>