searchState.loadedDescShard("calyx_opt", 0, "The Calyx Intermediate Language\nAnalysis for Calyx programs.\nDefines the default passes available to PassManager.\nDefine the PassManager structure that is used to construct …\nPasses for the Calyx compiler.\nSimple macro to register an alias with a pass manager.\nHelpers for traversing Control programs\nAnalyzes that can be performed on a set of assignments.\nStruct to perform compaction on <code>seqs</code>. It will only work if …\nAdding “NODE_ID”, “BEGIN_ID”, and “END_ID” …\nExtract the dependency order of a list of control programs.\nContains a mapping from name of ir::CombGroup to the ports …\nGiven a set of assignment, generates an ordering that …\nBuilds a Domination Map for the control program. It maps …\nStruct to store information about the go-done interfaces …\nConstructs a graph based representation of a component. …\nDefines a greedy graph coloring algorithm over a generic …\nDefault implemnetation is almost certainly not helpful. …\nExtra information needed to compute static information for …\nThis analysis implements a parallel version of a classic …\nNode can either be a SingleNode (i.e., a single node) or …\nRepresents a group of <code>Nodes</code> that execute in parallel.\nHelper methods to parse <code>@read_together</code> and <code>@write_together</code> …\nCalcuate the reads-from and writes-to set for a given set …\nA conflict graph that describes which nodes (i.e. …\nStores a Hashset that contains the type names of all …\n<code>SingleNode</code> struct.\nHelpful for translating queries for the FSMTree structure. …\nRepresents a static FSM (i.e., the actual register in …\nCalculate live ranges across static par blocks. Assumes …\nDetects if a group is solely being used to update a …\nTrait to propagate and extra “static” attributes …\nAdds id to self\nUpdates the component, given a component name and a new …\nAdds conflicts between nodes in the tree that execute at …\nAdd each edge in <code>edges</code> to the graph.\nUpdates the component, given a component name and a new …\nReturns an iterator containing all conflict edges, …\nReturns true if a control statement is already static, or …\nvec of (Node Object, cycles for which that child is …\nGiven an <code>ordering</code> of <code>T</code>s, find a mapping from nodes to <code>T</code>s …\nConstruct <code>@read_together</code> spec from the definition of a …\nConstruct @read_together specs from the primitive …\nTakes a vec of ctrl stmts and turns it into a compacted …\nCompute the static information for the type if possible …\nAdds the @NODE_ID attribute to all control stmts except …\nReturn a vector of all nodes that conflict with this nodes.\nChecks if id contains self\nReturns the ports that are read and written, respectively, …\nReturns the ports that are read and written, respectively, …\nReturns the cells that are read and written, respectively, …\nReturns the cells that are read and written, respectively, …\nConverts control to static control. Control must already …\nConverts vec of control to vec of static control. All …\nCount to n. Need to call <code>instantiate_fsms</code> before calling …\nCounts to N by recursively calling <code>count_to_n</code> on each …\nRestricts the analysis graph to only include edges that …\nMaps ids of control stmts, to the “last” nodes in …\n“Fixes Up” the component. In particular:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a shareset from the context. Looks for “…\nBuilds FixUp struct from a ctx. Looks at all primitives …\nKeep track of where we are within a single iteration. If …\nmaps cycles (i,j) -&gt; fsm state type. Here is an example …\nReturn a reference to the port reads associated with the …\nLook up the set of things live at a node (i.e. group or …\nGet a unique list of all live cells in <code>component</code>.\nReturn the entire invoke binding map.\nGet the names of all nodes (i.e., the names of the groups …\nGet all bindings for an instance\nGets the children of root of the tree (if a <code>Tree</code> variant) …\nGiven a control c and an id, finds the control statement …\nGet the name of the group at the root of the tree (if a …\nGets latency of the overall tree.\nReturns the latency associated with the provided @go port …\nUpdates live_once_map and par_thread_map. live_once_map …\nRecursively searches each thread to get the longest (in …\nGet max value of all nodes in the tree, according to some …\nIterate over the defined ports\nReturns Some(latency) if a control statement has a …\nGet the name of the root of the tree and return them. This …\nprovides a hashmap that gives the sharing frequencies\nReturn a total order for the control programs. Returns an …\nName of the <code>par_group</code> that fires off the threads\nChecks if there are cycles in the analysis graph.\nAdd a conflict edge between <code>a</code> and <code>b</code>.\nAdd conflict edges between all given items.\nInstantiate the necessary registers. The equivalent …\nInstantiates FSMs by recursively instantiating FSM for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this is a @done port\nIterate over the defined ports\nReturns true if this is @go port\nGiven a set of shareable and a cell, determines whether …\nReturns whether or not this instance is state_share\nIterate over the defined ports\nKeep track of which iteration we are on. If iteration …\nlatency of one iteration.\nLatency\ncomponent name -&gt; vec&lt;(go signal, done signal, latency)&gt;\nIterate over the defined ports\n<code>par_id</code> is the id of a par thread. <code>thread_a</code> and <code>thread_b</code> …\nTakes in static assignment <code>assign</code> and returns a dynamic …\nMap from node (either invokes, enables, or if/while ports) …\nConstruct a domination map.\nConstruct a live range analysis.\nConstruct a live range analysis.\nnumber of repeats. (So “total” latency = <code>latency</code> x …\nNum Repeats\nnumber of states in this node\nReturn a Vec of paths from <code>start</code> to <code>finish</code>, each path a …\nReturns ir::Port that are read from in the given …\nReturns all the <code>Port</code> associated with this instance.\nGet the equivalent fsm guard when the tree is between …\nUse the longest node to query between.\nCalculate the reaching definitions in a control program.\nReturns an iterator over all the reads from a port. …\n“Realize” the static groups into dynamic groups. The …\nRealizes static groups into dynamic group.\nRemove the port reads associated with the group.\nUpdates the component, given a component name and a new …\nRemove all vertices that have no undirected neighbors from …\nRemoves the @promotable attribute from the control program.\n(name of static group, assignments to build a …\nMaps static component names to their latencies, but there …\nan analysis to help domination across static pars static …\nTake the assignments of the root of the tree and return …\n(Thread, interval thread is active). Interval thread is …\nReturn a topological sort of this graph.\nUpdates self so that compaction will take continuous …\nCompute the static information for the type if possible …\nCompute the static information for the type if possible …\nA group is variable like if it:\nConstruct @write_together specs from the primitive …\nReturns an iterator over all the writes to this port. …\nA datastructure used to represent a set of …\nA wrapper enum to distinguish between Ids that come from …\nA struct used to compute a reaching definition analysis. …\nProvides a map containing a vector of sets for each …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a reaching definition analysis for registers …\nContains the error value\nContains the success value\nTop-level type for all passes that transform an ir::Context\nStructure that tracks all registered passes for the …\nAdds a new alias for groups of passes. An alias is a list …\nReturn a string representation to show all available …\nExecutes a given “plan” constructed using the incl and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRegisters a diagnostic pass as a normal pass. If there is …\nRegister a new Calyx pass and return an error if another …\nReturn the help string for a specific pass.\nPerform serval canonicalizations on the program.\nGiven a LiveRangeAnalysis that specifies the “share” …\nAdds assignments from a components <code>clk</code> port to every …\nCollapses and de-nests control constructs.\nPropagate unconditional reads and writes from wires.\nCompiles <code>ir::Invoke</code> statements into an <code>ir::Enable</code> that …\nCompiles <code>ir::Invoke</code> statements into an <code>ir::Enable</code> that …\nCompiles Static Islands\nInlines all sub-components marked with the <code>@inline</code> …\nReplaces ports with constants when we can infer the value …\nInfers <code>@control</code> and <code>@data</code> annotations for cells. A cell …\nRemoves unused assigns from groups. Analyzes the writes to …\nRemoves unused cells from components.\nRemoves unused groups and combinational groups from …\nAdds default assignments to all non-<code>@data</code> ports of an …\nResults generated from the process of dumping out ports.\nExternalize input/output ports for cells marked with the …\nAdd the group’s <code>go</code> signal into the guards of all …\nTransform groups that are structurally invoking components …\nTransforms a group into a seq of 2 smaller groups, if …\nThis pass checks if components are (state) shareable. Here …\nLowers guards into a purely structural representation. …\nMerge assignments of the form with the same (dst_port, …\nPass to check for common errors such as missing …\nAdds probe wires to each group to detect when a group is …\nRemoves NODE_ID, BEGIN_ID, and END_ID from each control …\nAdds assignments from a components <code>reset</code> port to every …\nSimplifies Static Guards In particular if g = g1 &amp; g2 &amp; ……\nTransforms combinational groups into normal groups by …\nAdds assignments from a components <code>clk</code> port to every …\nInfer @promotable annotation for groups and control. …\nPromote control to static when (conservatively) possible, …\nPass to check common synthesis issues.\n<strong>Core lowering pass.</strong> Compiles away the control programs in …\nFully unroll all <code>while</code> loops with a given <code>@bound</code>.\nPass to check if the program is well-formed.\nAlternate hole inliner that removes groups and group holes …\nIf the top-level component is not named <code>main</code>, adds a new …\nThe cells that were removed from the component.\nIf requested, emit FSM json after all components are …\nTransforms a <code>if-with</code> into a <code>seq-if</code> which first runs the …\nCompile each child in <code>par</code> block separately so each child …\nCollapse par { par { A }; B } into par { A; B }.\nCollapse seq { seq { A }; B } into seq { A; B }.\nCollapse static par {static par {A; B;}} into static par …\nCollapse\nCollase static seq {static seq {A; B; }} into static seq …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven a coloring of group names, returns a Hashmap that …\nCreates a graph (one node per item in <code>sgroup</code> where nodes …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRewrites from (cell, port) to the new port. Usually …\ntakes in g, and separates the “anded intervals” from …\nExecuted after visiting the children of a [ir::Static] …\nExecuted after visiting the children of a [ir::Static] …\nIf while body is static, then we want to make sure that …\nReturns the minimum bit width needed to represents n …\nloop through all control statements under “par” block …\nCompiles @sync without use of std_sync_reg Upon …\nA pass to detect cells that have been inlined into the …\nTurns memory cell primitives with the <code>@external(1)</code> …\nRemoves all groups and inlines reads and writes from holes.\nMetadata stores a Map between each group name and data …\nTransforms all <code>par</code> into <code>seq</code>. When the <code>correctness-checking</code> …\nUnsharing registers reduces the amount of multiplexers …\nCollapse par { par { A }; B } into par { A; B }.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an empty metadata table\nAction performed at the end of visiting a control …\nA boolean option.\nReplace the current ast node with a new node. If performed …\nDefine traversal order of components: pre-order, …\nTrait defining method that can be used to construct a …\nContinue traversal of control program.\nA type for accumulating multiple errors\nA pass that implements reporting Diagnostics\nAccumuate the error in a <code>Result</code> type into the …\nContains the error value\nA list of values.\nTrait that describes named things. Calling <code>do_pass</code> and …\nUse an arbitrary order.\nA number option.\nContains the success value\nThe order in which the components are traversed.\nAn output stream (stdout, stderr, file name)\nThe value returned from parsing an option.\nOption that can be passed to a pass.\nTraverse components in post-order.\nTraverse components in pre-order.\nSkips the traversal of this node’s children but …\nReplace the current StaticControl node with a new node If …\nGlobally abort traversal of control program.\nA string option.\nResult of performing a visit.\nDescribes types that can be visited by things implementing …\nThe visiting interface for a <code>ir::Control</code> program. Contains …\nTraverses components in post-order and applies <code>upd</code>.\nClear the data stored in the visitor. Called before …\nA short description of the pass.\nReturn an iterator of the diagnostics gathered by this …\nRun the visitor on a given program <code>ir::Context</code>. The …\nRun the visitor on a given program <code>ir::Context</code>. The …\nBuild a Default implementation of this pass and call …\nBuild a Default implementation of this pass and call …\nAccumulates <code>error</code> into the context, and returns …\nExecuted at an ir::Empty node.\nExecuted at an ir::Empty node.\nExecuted at an ir::Enable node.\nExecuted at an ir::Enable node.\nReport an <code>error</code>\nExecuted after the traversal ends. This method is always …\nExecuted after the traversal ends. This method is always …\nTransform the <code>ir::Context</code> after visiting the components.\nTransform the <code>ir::Context</code> after visiting the components.\nExecuted after visiting the children of a ir::If node.\nExecuted after visiting the children of a ir::If node.\nExecuted after visiting the children of a ir::Par node.\nExecuted after visiting the children of a ir::Par node.\nExecuted after visiting the children of a ir::Repeat node.\nExecuted after visiting the children of a ir::Repeat node.\nExecuted after visiting the children of a ir::Seq node.\nExecuted after visiting the children of a ir::Seq node.\nExecuted after visiting the conetnts of an …\nExecuted after visiting the conetnts of an …\nExecuted after visiting the children of a ir::StaticIf …\nExecuted after visiting the children of a ir::StaticIf …\nExecuted after visiting the children of a ir::StaticRepeat …\nExecuted after visiting the children of a ir::StaticRepeat …\nExecuted after visiting the children of a ir::While node.\nExecuted after visiting the children of a ir::While node.\nConstruct the visitor using information from the Context\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExecuted at an ir::Invoke node.\nExecuted at an ir::Invoke node.\nDefine the iteration order in which components should be …\nDefine the iteration order in which components should be …\nThe name of a pass. Is used for identifying passes.\nReturns a new instance the PostOrder iterator given a …\nReturns an output stream if it is not the null stream\nParse a list that should have exactly N elements. If …\nSet of options that can be passed to the pass. The options …\nSet of options that can be passed to the pass. The options …\nParse a number from a string.\nParse a list of numbers from a string.\nParse a String from a string.\nPrecondition for this pass to run on the program. If this …\nPrecondition for this pass to run on the program. If this …\nExecuted before the traversal begins.\nExecuted before the traversal begins.\nTransform the <code>ir::Context</code> before visiting the components.\nTransform the <code>ir::Context</code> before visiting the components.\nExecuted before visiting the children of a ir::If node.\nExecuted before visiting the children of a ir::If node.\nExecuted before visiting the children of a ir::Par node.\nExecuted before visiting the children of a ir::Par node.\nExecuted before visiting the children of a ir::Repeat node.\nExecuted before visiting the children of a ir::Repeat node.\nExecuted before visiting the children of a ir::Seq node.\nExecuted before visiting the children of a ir::Seq node.\nExecuted before visiting the contents of an …\nExecuted before visiting the contents of an …\nExecuted before visiting the children of a ir::StaticIf …\nExecuted before visiting the children of a ir::StaticIf …\nExecuted before visiting the children of a ir::StaticRepeat…\nExecuted before visiting the children of a ir::StaticRepeat…\nExecuted before visiting the children of a ir::While node.\nExecuted before visiting the children of a ir::While node.\nExecuted at an ir::StaticEnable node.\nExecuted at an ir::StaticEnable node.\nExecuted at a ir::StaticInvoke node.\nExecuted at a ir::StaticInvoke node.\nReturns the underlying component vector in original order.\nDefine the traversal over a component. Calls Visitor::start…\nDefine the traversal over a component. Calls Visitor::start…\nPerform the traversal.\nReport a <code>warning</code>")