<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Frontend Tutorial - Calyx Documentation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Calyx Language</li><li class="chapter-item expanded "><a href="../tutorial/language-tut.html"><strong aria-hidden="true">1.</strong> Language Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/multi-component.html"><strong aria-hidden="true">1.1.</strong> Multi-Component Designs</a></li><li class="chapter-item expanded "><a href="../lang/memories-by-reference.html"><strong aria-hidden="true">1.2.</strong> Passing Memories by Reference</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/ref.html"><strong aria-hidden="true">2.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/data-format.html"><strong aria-hidden="true">2.1.</strong> Data Format</a></li><li class="chapter-item expanded "><a href="../lang/static.html"><strong aria-hidden="true">2.2.</strong> Static Timing</a></li><li class="chapter-item expanded "><a href="../lang/sync.html"><strong aria-hidden="true">2.3.</strong> Experimental: Synchronization</a></li><li class="chapter-item expanded "><a href="../lang/undefined.html"><strong aria-hidden="true">2.4.</strong> Undefined Behaviors</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/attributes.html"><strong aria-hidden="true">3.</strong> Attributes</a></li><li class="chapter-item expanded affix "><li class="part-title">Running Calyx Programs</li><li class="chapter-item expanded "><a href="../fud/index.html"><strong aria-hidden="true">4.</strong> fud: The Calyx Driver</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../fud/examples.html"><strong aria-hidden="true">4.1.</strong> Examples</a></li><li class="chapter-item expanded "><a href="../fud/xilinx.html"><strong aria-hidden="true">4.2.</strong> Xilinx Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../fud/axi-gen.html"><strong aria-hidden="true">4.2.1.</strong> AXI Generation</a></li></ol></li><li class="chapter-item expanded "><a href="../fud/external.html"><strong aria-hidden="true">4.3.</strong> External Stages</a></li><li class="chapter-item expanded "><a href="../fud/multiple-paths.html"><strong aria-hidden="true">4.4.</strong> Multiple Paths</a></li><li class="chapter-item expanded "><a href="../fud/circt.html"><strong aria-hidden="true">4.5.</strong> CIRCT</a></li><li class="chapter-item expanded "><a href="../fud/resource-estimation.html"><strong aria-hidden="true">4.6.</strong> Resource Estimation</a></li></ol></li><li class="chapter-item expanded "><a href="../interpreter.html"><strong aria-hidden="true">5.</strong> The Calyx Interpreter</a></li><li class="chapter-item expanded affix "><li class="part-title">The Calyx Compiler</li><li class="chapter-item expanded "><a href="../compiler.html"><strong aria-hidden="true">6.</strong> The Calyx Compiler</a></li><li class="chapter-item expanded "><a href="../libraries/core.html"><strong aria-hidden="true">7.</strong> Primitive Library</a></li><li class="chapter-item expanded "><a href="../compiler-as-library.html"><strong aria-hidden="true">8.</strong> The calyx Library</a></li><li class="chapter-item expanded "><a href="../optimizations/dataflow.html"><strong aria-hidden="true">9.</strong> Dataflow Analysis</a></li><li class="chapter-item expanded "><a href="../debug/index.html"><strong aria-hidden="true">10.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../debug/cider.html"><strong aria-hidden="true">10.1.</strong> Logical Bugs</a></li><li class="chapter-item expanded "><a href="../debug/debug.html"><strong aria-hidden="true">10.2.</strong> Compilation Bugs</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Generating Calyx</li><li class="chapter-item expanded "><a href="../calyx-py.html"><strong aria-hidden="true">11.</strong> Emitting Calyx from Python</a></li><li class="chapter-item expanded "><a href="../tutorial/frontend-tut.html" class="active"><strong aria-hidden="true">12.</strong> Frontend Tutorial</a></li><li class="chapter-item expanded "><a href="../frontends/index.html"><strong aria-hidden="true">13.</strong> Frontend Compilers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../frontends/dahlia.html"><strong aria-hidden="true">13.1.</strong> Dahlia</a></li><li class="chapter-item expanded "><a href="../frontends/systolic-array.html"><strong aria-hidden="true">13.2.</strong> Systolic Array Generator</a></li><li class="chapter-item expanded "><a href="../frontends/tvm-relay.html"><strong aria-hidden="true">13.3.</strong> TVM Relay</a></li><li class="chapter-item expanded "><a href="../frontends/ntt.html"><strong aria-hidden="true">13.4.</strong> NTT Pipeline Generator</a></li><li class="chapter-item expanded "><a href="../frontends/mrxl.html"><strong aria-hidden="true">13.5.</strong> MrXL</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Tools</li><li class="chapter-item expanded "><a href="../tools/runt.html"><strong aria-hidden="true">14.</strong> Runt</a></li><li class="chapter-item expanded "><a href="../tools/data-gen.html"><strong aria-hidden="true">15.</strong> Data Gen</a></li><li class="chapter-item expanded "><a href="../tools/exp-generator.html"><strong aria-hidden="true">16.</strong> exp Generator</a></li><li class="chapter-item expanded "><a href="../tools/editor-highlighting.html"><strong aria-hidden="true">17.</strong> Editor Highlighting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Calyx Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="building-a-frontend-for-calyx"><a class="header" href="#building-a-frontend-for-calyx">Building a Frontend for Calyx</a></h1>
<p>In this tutorial, we're going to build a compiler for a small language called MrXL.</p>
<h2 id="mrxl-overview"><a class="header" href="#mrxl-overview">MrXL Overview</a></h2>
<p>MrXL provides constructs to create arrays, and perform <code>map</code> and <code>reduce</code> operations on those arrays. Here's an example of a dot product implementation in MrXL:</p>
<pre><code>input avec: int[4]
input bvec: int[4]
output dot: int[4]
prodvec := map 1 (a &lt;- avec, b &lt;- bvec) { a * b }
dot := reduce 1 (a, b &lt;- prodvec) 0 { a + b }
</code></pre>
<p>We define the interface of program by specifying <code>input</code> and <code>output</code> arrays.
Input arrays have their values populated by an external harness while the output arrays must be computed using the program.</p>
<p>A <code>map</code> expression iterates over multiple arrays of the same element and produces a new vector using the function provided in the body.
In the above example, the <code>map</code> expression multiplies the values of <code>avec</code> and <code>bvec</code>.
<code>map 1</code> states that the operation has a <em>parallelism factor</em> of 1 which means that the loop iterations are performed sequentially.</p>
<p><code>reduce</code> expressions walk over memories and accumulate a result into a register.
In the above code snippet, we add together all the elements of <code>prodvec</code> and place them in a register named <code>dot</code>.
Since the <code>reduce</code> parallelism factor is also 1, the reduction is performed sequentially.</p>
<h2 id="run-a-mrxl-program"><a class="header" href="#run-a-mrxl-program">Run a MrXL Program</a></h2>
<p>Once we have <a href="https://github.com/cucapra/futil/tree/master/frontends/mrxl">installed the mrxl command line tool</a>, we can run MrXL programs using <a href="../fud/index.html"><code>fud</code></a>.</p>
<p>To provide MrXL program with input values, we use fud's <a href="https://www.json.org/json-en.html">JSON</a>-based <a href="../lang/data-format.html">data format</a>.
Let's try to run this program, which has a parallelism factor of two:</p>
<pre><code>input foo: int[4]
output baz: int[4]
baz := map 2 (a &lt;- foo) { a + 5 }
</code></pre>
<p>In order to take advantage of the parallelism in the program, the MrXL compiler automatically partitions the input memory <code>foo</code> into two different <em>physical banks</em>: <code>foo_b0</code> and <code>foo_b1</code>.
Therefore, we split up our logical <code>foo</code> input of <code>[1, 2, 3, 4]</code> into <code>[1,2]</code> and <code>[3,4]</code>:</p>
<pre><code class="language-json">  &quot;foo_b0&quot;: {
    &quot;data&quot;: [
      1,
      2
    ],
    &quot;format&quot;: {
      &quot;numeric_type&quot;: &quot;bitnum&quot;,
      &quot;is_signed&quot;: false,
      &quot;width&quot;: 32
    }
  },
  &quot;foo_b1&quot;: {
    &quot;data&quot;: [
      3,
      4
    ],
    &quot;format&quot;: {
      &quot;numeric_type&quot;: &quot;bitnum&quot;,
      &quot;is_signed&quot;: false,
      &quot;width&quot;: 32
    }
  },
</code></pre>
<p>Our complete data file similarly splits up the input for <code>baz</code>.</p>
<p>Run the program with the complete data by typing:</p>
<pre><code>fud exec frontends/mrxl/test/add.mrxl \
    --from mrxl \
    --to vcd -s verilog.data frontends/mrxl/test/add.mrxl.data
</code></pre>
<h2 id="compiling-mrxl-to-calyx"><a class="header" href="#compiling-mrxl-to-calyx">Compiling MrXL to Calyx</a></h2>
<p>This guide will walk you through the steps to build a Python program that compiles MrXL programs to Calyx code.
The guide assumes some basic familiarity with Calyx.
Take a look at <a href="./language-tut.html">Calyx tutorial</a> if you need a refresher.</p>
<p>To simplify things, we'll make a few assumptions about MrXL programs:</p>
<ul>
<li>Every array in a MrXL program has the same length.</li>
<li>Every integer in our generated hardware will be 32 bits.</li>
<li>Every <code>map</code> and <code>reduce</code> body will be either a multiplication or addition of either an array element or an integer.</li>
</ul>
<p>The following sections will outline these two high level tasks:</p>
<ol>
<li>Parse MrXL into a representation we can process with Python</li>
<li>Generate Calyx code</li>
</ol>
<blockquote>
<p>You can find our <a href="https://github.com/cucapra/calyx/blob/master/frontends/mrxl/mrxl/gen_futil.py">complete implementation</a> in the Calyx repository.</p>
</blockquote>
<h3 id="parse-mrxl-into-an-ast"><a class="header" href="#parse-mrxl-into-an-ast">Parse MrXL into an AST</a></h3>
<p>To start, we'll parse this MrXL program into a Python AST representation. We chose to represent <a href="https://github.com/cucapra/futil/blob/mrxl/mrxl/mrxl/ast.py">AST</a> nodes with Python <code>dataclass</code>.
A program is a sequence of array declarations followed by computation statements:</p>
<pre><code class="language-python">@dataclass
class Prog:
    decls: List[Decl] # Memory declarations
    stmts: List[Stmt] # Map and reduce statements
</code></pre>
<p><code>Decl</code> nodes correspond to array declarations like <code>input avec: int[1024]</code>, and carry data about whether they're an <code>input</code> or <code>output</code> array, their name, and their type:</p>
<pre><code class="language-python">@dataclass
class Decl:
    input: bool  # Otherwise, output.
    name: str
    type: Type
</code></pre>
<p><code>Stmt</code> nodes represent statements such as <code>dot := reduce 4 (a, b &lt;- prodvec) 0 { a + b }</code>, and contain more nested nodes representing their function header and body, and type of operation.</p>
<pre><code class="language-python">@dataclass
class Stmt:
    dest: str
    op: Union[Map, Reduce]
</code></pre>
<p><a href="https://github.com/cucapra/calyx/blob/master/frontends/mrxl/mrxl/ast.py">The complete AST</a> defines the remaining AST nodes required to represent a MrXL program.</p>
<h3 id="generate-calyx-code"><a class="header" href="#generate-calyx-code">Generate Calyx Code</a></h3>
<p>The skeleton of a Calyx program has three sections, and looks like this:</p>
<pre><code>component main() -&gt; {
  cells {}
  wires {}
  control {}
}
</code></pre>
<p>The <a href="../lang/ref.html#cells">cells section</a> instantiates hardware units like adders, memories and registers.
The <a href="../lang/ref.html#the-wires-section">wires section</a> contains <a href="../lang/ref.html#group-definitions">groups</a> that connect
together hardware instances to perform some logical task such as incrementing a specific register.
Finally, the <a href="../lang/ref.html#the-control-operators">control section</a> <em>schedules</em> the execution of groups using control operators such as <code>seq</code>, <code>par</code>, and <code>while</code>.</p>
<p>We perform syntax-directed compilation by walking over nodes in the above AST and generating <code>cells</code>, <code>wires</code>, and <code>control</code> operations.</p>
<h4 id="calyx-embedded-dsl"><a class="header" href="#calyx-embedded-dsl">Calyx Embedded DSL</a></h4>
<p>To make it easy to generate the hardware, we'll use Calyx's <a href="https://github.com/cucapra/calyx/blob/master/calyx-py/test/builder_example.py"><code>builder</code> module</a> in Python:</p>
<pre><code class="language-python">import calyx.builder as cb

prog = cb.Builder() # A Calyx program
main = prog.component(&quot;main&quot;) # Create a component named &quot;main&quot;
</code></pre>
<h4 id="decl-nodes"><a class="header" href="#decl-nodes"><code>Decl</code> nodes</a></h4>
<p><code>Decl</code> nodes instantiate new memories and registers.
We need these to be instantiated in the <code>cells</code> section of our Calyx output.
We use Calyx's <code>std_reg</code> and <code>std_mem_d1</code> primitives to represent registers and memories:</p>
<pre><code class="language-C">import &quot;primitives/core.futil&quot;; // Import standard library

component main() -&gt; () {
  cells {
    // A memory with 4 32-bit elements. Indexed using a 6-bit value.
    foo = std_mem_d1(32, 4, 6);
    // A register that contains a 32-bit value
    r = std_reg(32);
  }
  ...
}
</code></pre>
<p>For each <code>Decl</code> node, we need to determine if we're instantiating a memory or a register, and then translate that to a corresponding Calyx declaration and place that inside the <code>cells</code> section of our generated program.</p>
<p>If a memory is used in a parallel <code>map</code> or <code>reduce</code>, we might need to create different physical banks for it.
We define a function to walk over the AST and compute the parallelism factor for each memory:</p>
<pre><code class="language-python">    # Collect banking factors.
    par_factor = compute_par_factors(prog.stmts)
</code></pre>
<p>Using this information, we can instantiate registers and memories for our inputs and outputs:</p>
<pre><code class="language-python">            for i in range(par):
                main.mem_d1(f&quot;{name}_b{i}&quot;, 32, arr_size // par, 32, is_external=True)
</code></pre>
<p>The <code>main.mem_d1</code> call is a function defined by the Calyx builder module to instantiate memories for a component.
By setting <code>is_external=True</code>, we're indicating that a memory declaration is a part of the program's input-output interface.</p>
<h3 id="compiling-map-operations"><a class="header" href="#compiling-map-operations">Compiling <code>Map</code> Operations</a></h3>
<p>For every map or reduce node, we need to generate Calyx code that iterates over an array, performs some kind of computation, and then stores the result of that computation.
For <code>map</code> operations, we'll perform a computation on an element of an input array, and then store the result in a result array.
We can use Calyx's <a href="../lang/ref.html#while">while loops</a> to iterate over an input array, perform the map's computation, and store the final value.
At a high level, we want to generate the following pieces of hardware:</p>
<ol>
<li>A register to store the current value of the loop index.</li>
<li>A comparator to check of the loop index is less than the array size.</li>
<li>An adder to increment the value of the index.</li>
<li>Hardware needed to implement the loop body computation.</li>
</ol>
<h4 id="loop-condition"><a class="header" href="#loop-condition">Loop Condition</a></h4>
<p>We define a <a href="../lang/ref.html#comb-group-definitions">combinational group</a> to perform the comparison <code>idx &lt; arr_size</code> that uses an <code>lt</code> cell.</p>
<pre><code class="language-python">    group_name = f&quot;cond_{suffix}&quot;
    cell = f&quot;lt_{suffix}&quot;
    lt = comp.cell(cell, Stdlib.op(&quot;lt&quot;, 32, signed=False))
    with comp.comb_group(group_name):
        lt.left = idx.out
        lt.right = cb.const(32, arr_size)
</code></pre>
<h4 id="index-increment"><a class="header" href="#index-increment">Index Increment</a></h4>
<pre><code class="language-python">    group_name = f&quot;incr_idx_{suffix}&quot;
    adder = comp.add(f&quot;incr_{suffix}&quot;, 32)
    with comp.group(group_name) as incr:
        adder.left = idx.out
        adder.right = 1
        idx.in_ = adder.out
        idx.write_en = 1
        incr.done = idx.done
</code></pre>
<p>The loop index increment is implemented using a [group][lf-group] and an adder (<code>adder</code>).
We provide the index's previous value and the constant 1 to the adder and write the adder's output into the register.
Because we're performing a stateful update of the register, we must wait for the register to state that it's committed the write by setting the group's done condition to the register's <code>done</code> signal.</p>
<h4 id="body-computation"><a class="header" href="#body-computation">Body Computation</a></h4>
<p>The final piece of the puzzle is the body's computation.
The corresponding group indexes into the input memories:</p>
<pre><code class="language-python">        with comp.group(f&quot;eval_body_{suffix}&quot;) as ev:
            # Index each array
            for bind in stmt.bind:
                # Map bindings have exactly one dest
                mem = comp.get_cell(f&quot;{name2arr[bind.dest[0]]}&quot;)
                mem.addr0 = idx.out
</code></pre>
<p>Because the builder module is an embedded DSL, we can simply use Python's <code>for</code> loop to generate all the required assignments for indexing.</p>
<p>This code instantiates an adder or a multiplier depending on the computation needed using the <code>expr_to_port</code> helper function:</p>
<pre><code class="language-python">            # Provide inputs to the op
            op.left = expr_to_port(body.lhs)
            op.right = expr_to_port(body.rhs)
</code></pre>
<p>And writes the value from the operation into the output memory:</p>
<pre><code class="language-py">            out_mem = comp.get_cell(f&quot;{dest}_b{bank}&quot;)
            out_mem.addr0 = idx.out
            out_mem.write_data = op.out
            # Multipliers are sequential so we need to manipulate go/done signals
            if body.op == &quot;mul&quot;:
                op.go = 1
                out_mem.write_en = op.done
            else:
                out_mem.write_en = 1
            ev.done = out_mem.done
</code></pre>
<p>This final operation is complex because we must account for whether we're using an adder or a multiplier.
Adders are <em>combinational</em>–they produce their output immediately–while multipliers are <em>sequential</em> and require multiple cycles to produce its output.</p>
<p>When using a mutliplier, we need to explicitly set its <code>go</code> signal to one and only write the output from the multiplier into the memory when its <code>done</code> signal is asserted.
We do this by assigning the memory's <code>write_en</code> (write enable) signal to the multiplier's done signal.
Finally, the group's computation is done when the memory write is committed.</p>
<h4 id="generating-control"><a class="header" href="#generating-control">Generating Control</a></h4>
<p>Once we have generated the hardware needed for our computation, we can schedule its computation using <a href="../lang/ref.html#the-control-operators">control operators</a>:</p>
<pre><code class="language-py">            While(
                CompPort(CompVar(port), &quot;out&quot;),
                CompVar(cond),
                SeqComp(
                    [
                        Enable(f&quot;eval_body_{suffix}&quot;),
                        Enable(incr),
                    ]
                ),
            )
</code></pre>
<p>We generate a while loop that checks that the index is less than the array size.
Then, it sequentially executes the computation for the body and increments the loop index.</p>
<h3 id="add-parallelization"><a class="header" href="#add-parallelization">Add Parallelization</a></h3>
<p>MrXL allows you to parallelize your <code>map</code> and <code>reduce</code> operations. Let's revisit the <code>map</code> example from earlier:</p>
<pre><code>input foo: int[4]
output baz: int[4]
baz := map 4 (a &lt;- foo) { a + 5 }
</code></pre>
<p>The number 4 specifies that four copies of the loop bodies should be executed in parallel.
Our implementation already creates <a href="#decl-nodes">memory banks</a> to allow for parallel accesses.
At a high-level, we can change the compilation for the <code>map</code> operation to produce <code>n</code> copies of the hardware we generate above and generate a control program that looks like this:</p>
<pre><code>par {
  while le_b0.out with cond_b0 { seq { eval_body_b0; incr_idx_b0; } }
  while le_b1.out with cond_b1 { seq { eval_body_b1; incr_idx_b1; } }
  while le_b2.out with cond_b2 { seq { eval_body_b2; incr_idx_b2; } }
  while le_b3.out with cond_b3 { seq { eval_body_b3; incr_idx_b3; } }
}
</code></pre>
<p>The <a href="../lang/ref.html#par"><code>par</code> operator</a> executes all the loops in parallel.
The <a href="https://github.com/cucapra/calyx/blob/master/frontends/mrxl/mrxl/gen_futil.py">full implementation</a> shows the necessary code to accomplish this which simply creates an outer loop to generate distinct hardware for each copy of the loop.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Hopefully this should be enough to get you started with writing your own MrXL compiler. Some more follow-up tasks you could try if you're interested:</p>
<ul>
<li>Read the code for compiling <code>reduce</code> statements and extend to support parallel reductions using <a href="http://www.cs.ucr.edu/~nael/217-f15/lectures/217-lec10.pdf">reduction trees</a>.</li>
<li>Implement code generation that allows memories that differ from one another in size.</li>
<li>Implement complex function body expressions. We only support binary operations with two operands, like <code>a + 5</code>.</li>
<li>Add a new <code>filter</code> operation to MrXL.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../calyx-py.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../frontends/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../calyx-py.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../frontends/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
