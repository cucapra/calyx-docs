<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Frontend Tutorial - Calyx Documentation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Calyx Language</li><li class="chapter-item expanded "><a href="../tutorial/language-tut.html"><strong aria-hidden="true">1.</strong> Language Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/multi-component.html"><strong aria-hidden="true">1.1.</strong> Multi-Component Designs</a></li><li class="chapter-item expanded "><a href="../lang/memories-by-reference.html"><strong aria-hidden="true">1.2.</strong> Passing Memories by Reference</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/ref.html"><strong aria-hidden="true">2.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../lang/data-format.html"><strong aria-hidden="true">2.1.</strong> Data Format</a></li><li class="chapter-item expanded "><a href="../lang/static.html"><strong aria-hidden="true">2.2.</strong> Static Timing</a></li><li class="chapter-item expanded "><a href="../lang/sync.html"><strong aria-hidden="true">2.3.</strong> Experimental: Synchronization</a></li><li class="chapter-item expanded "><a href="../lang/undefined.html"><strong aria-hidden="true">2.4.</strong> Undefined Behaviors</a></li></ol></li><li class="chapter-item expanded "><a href="../lang/attributes.html"><strong aria-hidden="true">3.</strong> Attributes</a></li><li class="chapter-item expanded affix "><li class="part-title">Running Calyx Programs</li><li class="chapter-item expanded "><a href="../fud/index.html"><strong aria-hidden="true">4.</strong> fud: The Calyx Driver</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../fud/examples.html"><strong aria-hidden="true">4.1.</strong> Examples</a></li><li class="chapter-item expanded "><a href="../fud/xilinx.html"><strong aria-hidden="true">4.2.</strong> Xilinx Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../fud/axi-gen.html"><strong aria-hidden="true">4.2.1.</strong> AXI Generation</a></li></ol></li><li class="chapter-item expanded "><a href="../fud/external.html"><strong aria-hidden="true">4.3.</strong> External Stages</a></li><li class="chapter-item expanded "><a href="../fud/multiple-paths.html"><strong aria-hidden="true">4.4.</strong> Multiple Paths</a></li><li class="chapter-item expanded "><a href="../fud/circt.html"><strong aria-hidden="true">4.5.</strong> CIRCT</a></li><li class="chapter-item expanded "><a href="../fud/resource-estimation.html"><strong aria-hidden="true">4.6.</strong> Resource Estimation</a></li></ol></li><li class="chapter-item expanded "><a href="../interpreter.html"><strong aria-hidden="true">5.</strong> The Calyx Interpreter</a></li><li class="chapter-item expanded affix "><li class="part-title">Compile Development Guide</li><li class="chapter-item expanded "><a href="../compiler.html"><strong aria-hidden="true">6.</strong> The Calyx Compiler</a></li><li class="chapter-item expanded "><a href="../new-pass.html"><strong aria-hidden="true">7.</strong> Adding a New Pass</a></li><li class="chapter-item expanded "><a href="../libraries/core.html"><strong aria-hidden="true">8.</strong> Primitive Library</a></li><li class="chapter-item expanded "><a href="../compiler-as-library.html"><strong aria-hidden="true">9.</strong> The calyx Library</a></li><li class="chapter-item expanded "><a href="../optimizations/dataflow.html"><strong aria-hidden="true">10.</strong> Dataflow Analysis</a></li><li class="chapter-item expanded "><a href="../debug/index.html"><strong aria-hidden="true">11.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../debug/cider.html"><strong aria-hidden="true">11.1.</strong> Logical Bugs</a></li><li class="chapter-item expanded "><a href="../debug/debug.html"><strong aria-hidden="true">11.2.</strong> Compilation Bugs</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Generating Calyx</li><li class="chapter-item expanded "><a href="../calyx-py.html"><strong aria-hidden="true">12.</strong> Emitting Calyx from Python</a></li><li class="chapter-item expanded "><a href="../tutorial/frontend-tut.html" class="active"><strong aria-hidden="true">13.</strong> Frontend Tutorial</a></li><li class="chapter-item expanded "><a href="../frontends/index.html"><strong aria-hidden="true">14.</strong> Frontend Compilers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../frontends/dahlia.html"><strong aria-hidden="true">14.1.</strong> Dahlia</a></li><li class="chapter-item expanded "><a href="../frontends/systolic-array.html"><strong aria-hidden="true">14.2.</strong> Systolic Array Generator</a></li><li class="chapter-item expanded "><a href="../frontends/tvm-relay.html"><strong aria-hidden="true">14.3.</strong> TVM Relay</a></li><li class="chapter-item expanded "><a href="../frontends/ntt.html"><strong aria-hidden="true">14.4.</strong> NTT Pipeline Generator</a></li><li class="chapter-item expanded "><a href="../frontends/mrxl.html"><strong aria-hidden="true">14.5.</strong> MrXL</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Tools</li><li class="chapter-item expanded "><a href="../tools/runt.html"><strong aria-hidden="true">15.</strong> Runt</a></li><li class="chapter-item expanded "><a href="../tools/data-gen.html"><strong aria-hidden="true">16.</strong> Data Gen</a></li><li class="chapter-item expanded "><a href="../tools/exp-generator.html"><strong aria-hidden="true">17.</strong> exp Generator</a></li><li class="chapter-item expanded "><a href="../tools/editor-highlighting.html"><strong aria-hidden="true">18.</strong> Editor Highlighting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Calyx Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="building-a-frontend-for-calyx"><a class="header" href="#building-a-frontend-for-calyx">Building a Frontend for Calyx</a></h1>
<blockquote>
<p>This tutorial assumes that you have already worked through the <a href="./language-tut.html">Calyx tutorial</a>. You won't get very much out of it by itself!</p>
</blockquote>
<p>In the <a href="./language-tut.html">Calyx tutorial</a> you wrote Calyx code by hand.
This is (probably) a good way to build character, but it's no way to live.
Indeed, Calyx was <em>designed</em> to be a compiler IL, and not a human-facing language.</p>
<p>In this tutorial, we're going to learn all about this by building a DSL-to-hardware compiler for a toy language that we wish to accelerate.
We will compile the DSL to Calyx, and then let Calyx take us to hardware.</p>
<p>Change your directory to <code>frontends/mrxl/</code>.</p>
<h1 id="mrxl-overview"><a class="header" href="#mrxl-overview">MrXL Overview</a></h1>
<p>Meet MrXL, our toy DSL.
MrXL lets you define arrays and registers and then perform <code>map</code> and <code>reduce</code> operations.</p>
<h2 id="example-sum-of-squares"><a class="header" href="#example-sum-of-squares">Example: sum of squares</a></h2>
<p>Here's a MrXL program that squares and then sums the values of an input array:</p>
<pre><code>input avec: int[4]
output sos: int
squares := map 1 (a &lt;- avec) { a * a }
sos := reduce 1 (acc, i &lt;- squares) 0 { acc + i }
</code></pre>
<p>This short program shows off all of MrXL's features, so let's pick it apart line by line:</p>
<ol>
<li>We specify an array, <code>avec</code>, which will have four integers. The <code>input</code> keyword means that an external harness will populate the array.</li>
<li>We specify <code>sos</code>, a register. The <code>output</code> keyword means that we will populate <code>sos</code> in our program.</li>
<li>The <code>map</code> operation gets the values of <code>avec</code> and raises each to the second power. We stash the result in a new array, <code>squares</code>. The number <code>1</code> denotes a <em>parallelism factor</em> of 1, meaning that the operation is performed sequentially. We will improve this shortly.</li>
<li>The <code>reduce</code> operation walks over <code>squares</code> and accumulates the result into a register. The parallelism factor is again <code>1</code>.</li>
</ol>
<h2 id="running-our-example"><a class="header" href="#running-our-example">Running our example</a></h2>
<p>To begin, we will install the MrXL command line tool:</p>
<ol>
<li>Install <a href="https://flit.readthedocs.io/en/latest/index.html"><code>flit</code></a>: <code>pip install flit</code> or similar.</li>
<li>Install the <code>calyx-py</code> library: <code>cd ../../calyx-py &amp;&amp; flit install -s &amp;&amp; cd -</code>.</li>
<li>Run <code>flit install -s</code>.</li>
<li>Run <code>fud register mrxl -p fud/mrxl.py</code>.</li>
<li>Run <code>fud check</code> and ensure that <code>fud</code> sees <code>mrxl</code>.</li>
</ol>
<p>Now change directories to <code>calyx/frontends/mrxl</code> and run:</p>
<pre><code>mrxl test/sos.mrxl --data test/sos.mrxl.data --interpret
</code></pre>
<p>Why <code>42</code>? Because we populated <code>avec</code> with:</p>
<pre><code class="language-json">{
  &quot;avec&quot;: [
    0,
    1,
    4,
    5
  ]
}
</code></pre>
<p>and \( 0^2 + 1^2 + 4^2 + 5^2 = 42 \).</p>
<h2 id="compiling-our-example-into-calyx"><a class="header" href="#compiling-our-example-into-calyx">Compiling our example into Calyx</a></h2>
<p>Above, we merely <em>interpreted</em> MrXL code in software using a simple, pre-written interpreter implemented in Python.
Our goal in this tutorial is to build a compiler from MrXL to hardware by translating it to the Calyx IL.
The Calyx IL code generated by compiling this program looks more like:</p>
<details>
<summary>Click to expand 103 lines.</summary>
<pre><code>import &quot;primitives/core.futil&quot;;
import &quot;primitives/binary_operators.futil&quot;;
component main() -&gt; () {
  cells {
    @external avec_b0 = std_mem_d1(32, 4, 32);
    @external sos = std_mem_d1(32, 1, 32);
    sos_reg = std_reg(32);
    squares_b0 = std_mem_d1(32, 4, 32);
    idx_b0_0 = std_reg(32);
    incr_b0_0 = std_add(32);
    lt_b0_0 = std_lt(32);
    mul_b0_0 = std_mult_pipe(32);
    idx1 = std_reg(32);
    incr_1 = std_add(32);
    lt_1 = std_lt(32);
    add_1 = std_add(32);
  }
  wires {
    group sos_reg2mem {
      sos.addr0 = 32'd0;
      sos.write_data = sos_reg.out;
      sos.write_en = 1'd1;
      sos_reg2mem[done] = sos.done;
    }
    group incr_idx_b0_0 {
      incr_b0_0.left = idx_b0_0.out;
      incr_b0_0.right = 32'd1;
      idx_b0_0.in = incr_b0_0.out;
      idx_b0_0.write_en = 1'd1;
      incr_idx_b0_0[done] = idx_b0_0.done;
    }
    comb group cond_b0_0 {
      lt_b0_0.left = idx_b0_0.out;
      lt_b0_0.right = 32'd4;
    }
    group eval_body_b0_0 {
      avec_b0.addr0 = idx_b0_0.out;
      mul_b0_0.left = avec_b0.read_data;
      mul_b0_0.right = avec_b0.read_data;
      squares_b0.addr0 = idx_b0_0.out;
      squares_b0.write_data = mul_b0_0.out;
      mul_b0_0.go = 1'd1;
      squares_b0.write_en = mul_b0_0.done;
      eval_body_b0_0[done] = squares_b0.done;
    }
    group init_idx_1 {
      idx1.in = 32'd0;
      idx1.write_en = 1'd1;
      init_idx_1[done] = idx1.done;
    }
    group incr_idx_1 {
      incr_1.left = idx1.out;
      incr_1.right = 32'd1;
      idx1.in = incr_1.out;
      idx1.write_en = 1'd1;
      incr_idx_1[done] = idx1.done;
    }
    comb group cond_1 {
      lt_1.left = idx1.out;
      lt_1.right = 32'd4;
    }
    group init_1 {
      sos_reg.in = 32'd0;
      sos_reg.write_en = 1'd1;
      init_1[done] = sos_reg.done;
    }
    group reduce1 {
      squares_b0.addr0 = idx1.out;
      add_1.left = sos_reg.out;
      add_1.right = squares_b0.read_data;
      sos_reg.in = add_1.out;
      sos_reg.write_en = 1'd1;
      reduce1[done] = sos_reg.done;
    }
  }
  control {
    seq {
      par {
        while lt_b0_0.out with cond_b0_0 {
          seq {
            eval_body_b0_0;
            incr_idx_b0_0;
          }
        }
      }
      seq {
        par {
          init_1;
          init_idx_1;
        }
        while lt_1.out with cond_1 {
          seq {
            reduce1;
            incr_idx_1;
          }
        }
      }
      par {
        sos_reg2mem;
      }
    }
  }
}
</code></pre>
</details>
<p>Generate it for yourself! Run:</p>
<pre><code>mrxl test/sos.mrxl
</code></pre>
<h1 id="compiling-mrxl-into-calyx"><a class="header" href="#compiling-mrxl-into-calyx">Compiling MrXL into Calyx</a></h1>
<p>Any frontend can support new commands that are relevant to the domain of interest, so long as those commands can themselves be compiled into Calyx.
We will now step back from our example and study <a href="https://github.com/cucapra/calyx/blob/master/frontends/mrxl/mrxl/gen_calyx.py">the MrXL-to-Calyx compiler</a>, written in Python.</p>
<p>We have placed a few simplifying restrictions on MrXL programs:</p>
<ol>
<li>Every array in a MrXL program has the same length.</li>
<li>Every integer in our generated hardware is 32 bits long.</li>
<li>The bodies of <code>map</code> and <code>reduce</code> operations must be binary <code>+</code> or <code>*</code> operations involving array elements or integers.</li>
<li>If repeated <code>map</code>/<code>reduce</code> operations are performed on the same array, each of those operations must have the same parallelism factor.</li>
<li>All <code>reduce</code> operations must be formed sequentially, i.e., with parallelism factor <code>1</code>.</li>
</ol>
<p>These restrictions can be lifted or relaxed via commensurate changes to the compiler.</p>
<p>The compilation process breaks into two steps:</p>
<ol>
<li>Parsing MrXL into a representation we can process in Python.</li>
<li>Generating Calyx code.</li>
</ol>
<h2 id="parsing-mrxl-into-an-ast"><a class="header" href="#parsing-mrxl-into-an-ast">Parsing MrXL into an AST</a></h2>
<p>To start, we'll parse the MrXL program into a Python AST representation.
We choose to represent <a href="https://github.com/cucapra/calyx/blob/mrxl/mrxl/mrxl/ast.py">AST</a> nodes with Python <code>dataclass</code>es.
A program is a sequence of array/register declarations followed by computation statements:</p>
<pre><code class="language-python">@dataclass
class Prog:
    &quot;&quot;&quot;A MrXL program.&quot;&quot;&quot;
    decls: List[Decl]  # Memory declarations
    stmts: List[Stmt]  # Map and reduce statements
</code></pre>
<p><code>Decl</code> nodes correspond to array declarations such as <code>input avec: int[4]</code>.
They carry information about whether the array is an <code>input</code> or <code>output</code>, the array's name, and the type of the array's elements:</p>
<pre><code class="language-python">@dataclass
class Decl:
    &quot;&quot;&quot;Declaration of a memory.&quot;&quot;&quot;
    input: bool  # If `False`, this is an `output`.
    name: str
    type: Type
</code></pre>
<p><code>Stmt</code> nodes represent statements such as <code>sos := reduce 1 (acc, i &lt;- squares) 0 { acc + i }</code>.
They contain further nested nodes representing the function-header and -body, and the type of operation:</p>
<pre><code class="language-python">@dataclass
class Stmt:
    &quot;&quot;&quot;A statement in the program.&quot;&quot;&quot;
    dst: str
    operation: Union[Map, Reduce]
</code></pre>
<p>We elide further details, but point you to the <a href="https://github.com/cucapra/calyx/blob/master/frontends/mrxl/mrxl/ast.py">AST</a>, which defines all the nodes we need to represent a MrXL program.</p>
<h2 id="generating-calyx-code"><a class="header" href="#generating-calyx-code">Generating Calyx code</a></h2>
<p><a href="./language-tut.html">As you know</a>, the skeleton of a Calyx program has three sections:</p>
<pre><code>component main() -&gt; {
  cells {}
  wires {}
  control {}
}
</code></pre>
<p>The <a href="../lang/ref.html#cells">cells section</a> instantiates hardware units like adders, memories and registers.
The <a href="../lang/ref.html#the-wires-section">wires section</a> contains <a href="../lang/ref.html#group-definitions">groups</a> that connect
hardware instances to perform some logical task (e.g, incrementing a register).
Finally, the <a href="../lang/ref.html#the-control-operators">control section</a> <em>schedules</em> the execution of groups using control operators such as <code>seq</code>, <code>par</code>, and <code>while</code>.</p>
<p>We perform syntax-directed compilation by walking over the nodes of the AST and generating <code>cells</code>, <code>wires</code>, and <code>control</code> operations.</p>
<h3 id="calyx-embedded-dsl"><a class="header" href="#calyx-embedded-dsl">Calyx-Embedded DSL</a></h3>
<p>To make it easy to generate hardware, we'll use Calyx's <a href="https://github.com/cucapra/calyx/blob/master/calyx-py/test/builder_example.py"><code>builder</code> module</a> written in Python:</p>
<pre><code class="language-python">import calyx.builder as cb

prog = cb.Builder() # A Calyx program
main = prog.component(&quot;main&quot;) # Create a component named &quot;main&quot;
</code></pre>
<h3 id="decl-nodes"><a class="header" href="#decl-nodes"><code>Decl</code> nodes</a></h3>
<p><code>Decl</code> nodes instantiate new memories and registers.
We need these to be instantiated in the <code>cells</code> section of our Calyx output.
We use Calyx's <code>std_reg</code> and <code>std_mem_d1</code> primitives to represent registers and memories:</p>
<pre><code class="language-C">import &quot;primitives/core.futil&quot;; // Import standard library

component main() -&gt; () {
  cells {
    // A memory with 4 32-bit elements. Indexed using a 6-bit value.
    avec = std_mem_d1(32, 4, 6);
    // A register that contains a 32-bit value
    sos = std_reg(32);
  }
  ...
}
</code></pre>
<p>For each <code>Decl</code> node, we need to determine if we're instantiating a memory or a register, translate the node into a corresponding Calyx declaration, and place the declaration inside the <code>cells</code> section of our generated program.</p>
<p>If a memory is used in a parallel <code>map</code> or <code>reduce</code>, we might need to create different physical banks for it.
We define a function to walk over the AST and compute the parallelism factor for each memory:</p>
<pre><code class="language-python">    # Collect banking factors.
    par_factor = compute_par_factors(prog.stmts)
</code></pre>
<p>Using this information, we can instantiate registers and memories for our inputs and outputs:</p>
<pre><code class="language-python">            for i in range(par):
                main.mem_d1(f&quot;{name}_b{i}&quot;, 32, arr_size // par, 32, is_external=True)
</code></pre>
<p>The <code>main.mem_d1</code> call is a function defined by the Calyx builder module to instantiate memories for a component.
By setting <code>is_external=True</code>, we're indicating that a memory declaration is a part of the program's input-output interface.</p>
<h2 id="compiling-map-operations"><a class="header" href="#compiling-map-operations">Compiling <code>map</code> operations</a></h2>
<p>For every <code>map</code> or <code>reduce</code> node, we need to generate Calyx code that iterates over an array, performs some kind of computation, and then stores the result of that computation.
For <code>map</code> operations, we'll perform a computation on an element of an input array, and then store the result in a result array.
We can use Calyx's <a href="../lang/ref.html#while">while loops</a> to iterate over an input array, perform the map's computation, and store the final value.
At a high level, we want to generate the following pieces of hardware:</p>
<ol>
<li>A register to store the current value of the loop index.</li>
<li>A comparator to check of the loop index is less than the array size.</li>
<li>An adder to increment the value of the index.</li>
<li>Whatever hardware is needed to implement the loop body computation.</li>
</ol>
<h3 id="loop-condition"><a class="header" href="#loop-condition">Loop condition</a></h3>
<p>We define a <a href="../lang/ref.html#comb-group-definitions">combinational group</a> to perform the comparison <code>idx &lt; arr_size</code> that uses an <code>lt</code> cell:</p>
<pre><code class="language-python">    group_name = f&quot;cond_{suffix}&quot;
    cell = f&quot;lt_{suffix}&quot;
    less_than = comp.cell(cell, Stdlib.op(&quot;lt&quot;, 32, signed=False))
    with comp.comb_group(group_name):
        less_than.left = idx.out
        less_than.right = cb.const(32, arr_size)
</code></pre>
<h3 id="index-increment"><a class="header" href="#index-increment">Index increment</a></h3>
<p>The loop index increment is implemented using a <a href="../lang/ref.html#group-definitions">group</a> and an <code>adder</code>:</p>
<pre><code class="language-python">    group_name = f&quot;incr_idx_{suffix}&quot;
    adder = comp.add(f&quot;incr_{suffix}&quot;, 32)
    with comp.group(group_name) as incr:
        adder.left = idx.out
        adder.right = 1
        idx.in_ = adder.out
        idx.write_en = 1
        incr.done = idx.done
</code></pre>
<p>We provide the index's previous value and the constant <code>1</code> to the adder, and write the adder's output into the register.
Because we're performing a stateful update of the register, we must wait for the register to state that it has committed the write.
We do this by setting the group's <code>done</code> condition to track the register's <code>done</code> signal.</p>
<h3 id="body-computation"><a class="header" href="#body-computation">Body computation</a></h3>
<p>The final piece of the puzzle is the body's computation.
The corresponding group indexes into the input memories:</p>
<pre><code class="language-python">        with comp.group(f&quot;eval_body_{suffix}&quot;) as evl:
            # Index each array
            for bind in stmt.binds:
                # Map bindings have exactly one dest
                mem = comp.get_cell(f&quot;{name2arr[bind.dst[0]]}&quot;)
                mem.addr0 = idx.out
</code></pre>
<p>Because the builder module is an embedded DSL, we can simply use Python's <code>for</code> loop to generate all the required assignments for indexing.</p>
<p>This code instantiates an adder or a multiplier depending on the computation needed using the <code>expr_to_port</code> helper function:</p>
<pre><code class="language-python">            # Provide inputs to the op
            operation.left = expr_to_port(body.lhs)
            operation.right = expr_to_port(body.rhs)
</code></pre>
<p>and writes the value from the operation into the output memory:</p>
<pre><code class="language-py">            out_mem = comp.get_cell(f&quot;{dest}_b{bank}&quot;)
            out_mem.addr0 = idx.out
            out_mem.write_data = operation.out
            # Multipliers are sequential so we need to manipulate go/done signals
            if body.operation == &quot;mul&quot;:
                operation.go = 1
                out_mem.write_en = operation.done
            else:
                out_mem.write_en = 1
            evl.done = out_mem.done
</code></pre>
<p>This final operation is complicated because we must account for whether we're using an adder or a multiplier.
Adders are <em>combinational</em>–they produce their output immediately–while multipliers are <em>sequential</em> and require multiple cycles to produce its output.</p>
<p>When using a mutliplier, we need to explicitly set its <code>go</code> signal to one and only write the output from the multiplier into the memory when its <code>done</code> signal is asserted.
We do this by assigning the memory's <code>write_en</code> (write enable) signal to the multiplier's done signal.
Finally, the group's computation is done when the memory write is committed.</p>
<h3 id="generating-control"><a class="header" href="#generating-control">Generating control</a></h3>
<p>Once we have generated the hardware needed for our computation, we can schedule its computation using <a href="../lang/ref.html#the-control-operators">control operators</a>:</p>
<pre><code class="language-py">            While(
                CompPort(CompVar(port), &quot;out&quot;),
                CompVar(cond),
                SeqComp(
                    [
                        Enable(f&quot;eval_body_{suffix}&quot;),
                        Enable(incr),
                    ]
                ),
            )
</code></pre>
<p>We generate a while loop that checks that the index is less than the array size.
Then, it sequentially executes the computation for the body and increments the loop index.</p>
<h2 id="adding-parallelization"><a class="header" href="#adding-parallelization">Adding parallelization</a></h2>
<p>MrXL allows us to parallelize our <code>map</code> operations.</p>
<p>Consider a variation on our prior example:</p>
<pre><code>input avec: int[4]
output squares: int[4]
squares := map 2 (a &lt;- avec) { a * a }
</code></pre>
<p>The noteworthy change is the parallelism factor of the <code>map</code> operation.
The parallelism factor <code>2</code> specifies that two copies of the loop bodies should be executed in parallel.
Our implementation automatically generates code that takes advantage of <a href="#decl-nodes">memory banking</a> in the supplied data.
This allows for parallel accesses.
It also creates an obligation on the data-supply side; we will show how to discharge this shortly.</p>
<p>At a high level, we can change the compilation of the <code>map</code> operation to produce two copies of the hardware we generated above.
We can generate a control program that looks like:</p>
<pre><code>par {
  while le_b0.out with cond_b0 { seq { eval_body_b0; incr_idx_b0; } }
  while le_b1.out with cond_b1 { seq { eval_body_b1; incr_idx_b1; } }
}
</code></pre>
<p>The <a href="../lang/ref.html#par"><code>par</code> operator</a> executes all the loops in parallel.
The <a href="https://github.com/cucapra/calyx/blob/master/frontends/mrxl/mrxl/gen_calyx.py">complete implementation</a> shows the necessary code to accomplish this which simply creates an outer loop to generate distinct hardware for each copy of the loop.</p>
<h1 id="supplying-data-to-mrxl-programs"><a class="header" href="#supplying-data-to-mrxl-programs">Supplying data to MrXL programs</a></h1>
<p>You may have noticed that the data files that we pass to MrXL programs are lighter-weight than those we pass to Calyx programs.
They are lighter in two ways.</p>
<h2 id="boilerplate"><a class="header" href="#boilerplate">Boilerplate</a></h2>
<p>Calyx requires cells to be allocated for the output cells.
Instead of asking the user to supply zeroed-out arrays and registers for output cells, we can infer the need for these output cells from the source code.
We can then add these on to the MrXL-native data files to make them amenable to Calyx.</p>
<p>Additionally, because MrXL supports only a few kinds of data, some interesting parameters of Calyx-native data files turn into &quot;just boilerplate&quot; in MrXL-native data.
We can keep MrXL-native data files relatively light and add this <code>format</code> information automatically.</p>
<h2 id="memory-banking"><a class="header" href="#memory-banking">Memory banking</a></h2>
<p>Let us look back at our example featuring a parallel <code>map</code>:</p>
<pre><code>input avec: int[4]
output squares: int[4]
squares := map 2 (a &lt;- avec) { a * a }
</code></pre>
<p>Interpret this with:</p>
<pre><code>mrxl test/squares.mrxl --data test/squares.mrxl.data --interpret
</code></pre>
<p>But more interestingly, compile this to Calyx IL with:</p>
<pre><code>mrxl test/squares.mrxl
</code></pre>
<p>There's a lot going on, but the thing to focus on is this.
To take advantage of the parallelism in the program, the MrXL compiler assumes that the input memory <code>avec</code> is split into two <em>banks</em>, <code>avec_b0</code> and <code>avec_b1</code>.
Look for these in the Calyx code.</p>
<p>When it comes time to populating the memories of this Calyx code, we can no longer just supply values for a memory <code>avec</code>.
We need to also bank the data that we supply, i.e., we must populate <code>avec_b0</code> and <code>avec_b1</code>.</p>
<p>Though nontrivial, this data-banking can also be handled automatically; all the necessary information is in the MrXL source program.</p>
<h2 id="example-squaresmrxldata"><a class="header" href="#example-squaresmrxldata">Example: <code>squares.mrxl.data</code></a></h2>
<p>Let us look at these changes in practice.</p>
<p>We write <code>avec</code>'s values as a straightforward array:</p>
<pre><code class="language-json">{
	&quot;avec&quot;: [
			0,
			1,
			4,
			5
		]
}
</code></pre>
<p>but under the hood, the <em>Calyx IL version</em> of <code>squares.mrxl</code> comes to expect something of the form:</p>
<pre><code class="language-json">{
    &quot;avec_b0&quot;: {
        &quot;data&quot;: [
            0,
            1
        ],
        &quot;format&quot;: {
            &quot;is_signed&quot;: false,
            &quot;numeric_type&quot;: &quot;bitnum&quot;,
            &quot;width&quot;: 32
        }
    },
    &quot;avec_b1&quot;: {
        &quot;data&quot;: [
            4,
            5
        ],
        &quot;format&quot;: {
            &quot;is_signed&quot;: false,
            &quot;numeric_type&quot;: &quot;bitnum&quot;,
            &quot;width&quot;: 32
        }
    },
    &quot;squares_b0&quot;: {
        &quot;data&quot;: [
            0,
            0
        ],
        &quot;format&quot;: {
            &quot;is_signed&quot;: false,
            &quot;numeric_type&quot;: &quot;bitnum&quot;,
            &quot;width&quot;: 32
        }
    },
    &quot;squares_b1&quot;: {
        &quot;data&quot;: [
            0,
            0
        ],
        &quot;format&quot;: {
            &quot;is_signed&quot;: false,
            &quot;numeric_type&quot;: &quot;bitnum&quot;,
            &quot;width&quot;: 32
        }
    }
}
</code></pre>
<p>And we can generate this automatically. Try it yourself:</p>
<pre><code>mrxl test/squares.mrxl --data test/squares.mrxl.data --convert
</code></pre>
<p>This transformation is achieved using a <a href="../fud/index.html"><code>fud</code></a> pass that converts MrXL-native data files into Calyx-native data files.</p>
<h1 id="further-steps"><a class="header" href="#further-steps">Further Steps</a></h1>
<p>Congratulations, you know about as much about MrXL as we do!
The small size of the language makes it a nice sandbox for you to play in.
We mentioned that the restrictions placed on the language can be lifted by beefing up the compiler, and here's your chance to give it a whirl!</p>
<p>As a warmup, you could try lifting one of the following restrictions:</p>
<blockquote>
<ol>
<li>Every array in a MrXL program has the same length.</li>
<li>Every integer in our generated hardware is 32 bits long.</li>
<li>The bodies of <code>map</code> and <code>reduce</code> operations must be binary <code>+</code> or <code>*</code> operations involving array elements or integers.</li>
</ol>
</blockquote>
<p>If you're looking for a more serious challenge, try:</p>
<blockquote>
<ol start="4">
<li>If repeated <code>map</code>/<code>reduce</code> operations are performed on the same array, each of those operations must have the same parallelism factor. You will very likely need to think about <em>arbitration logic</em>, so we provide a toy implementation using the <code>builder</code> <a href="https://github.com/cucapra/calyx/blob/master/calyx-py/test/arbiter_6.py">here</a>.</li>
</ol>
</blockquote>
<p>Or, for something completely different:</p>
<ol start="5">
<li>Add support for a new <code>filter</code> operation in MrXL.</li>
</ol>
<p>A big gap in MrXL at present is that all <code>reduce</code> operations must be performed sequentially.
This restriction can also be lifted, but hold that thought for a moment!
We'd like to tell you a little about reduction trees. Again, we provide a toy implementation using the <code>builder</code> <a href="https://github.com/cucapra/calyx/blob/master/calyx-py/test/reduction_tree.py">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../calyx-py.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../frontends/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../calyx-py.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../frontends/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
